////////////////////////////////////////////////////////////////////////
// Class:       SimPMTSBND
// Module Type: producer
// File:        SimPMTSBND_module.cc
//
// Generated at Sun Nov 12 15:21:31 2017 by Laura Paulucci Marinho - externo using artmod
// from cetpkgsupport v1_13_00.
////////////////////////////////////////////////////////////////////////

#include "canvas/Utilities/Exception.h"
#include "canvas/Utilities/InputTag.h"
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "art/Framework/Services/Optional/RandomNumberGenerator.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <vector>
#include <cmath>
#include <string>
#include <map>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <bitset>

extern "C" {
#include <sys/types.h>
#include <sys/stat.h>
}

//art extensions
#include "nutools/RandomUtils/NuRandomService.h"

#include "lardata/Utilities/LArFFT.h"
#include "lardataobj/RawData/RawDigit.h"
#include "lardataobj/RawData/raw.h"
#include "lardataobj/RawData/TriggerData.h"
#include "lardataobj/RawData/OpDetWaveform.h"
#include "lardata/DetectorInfoServices/DetectorClocksServiceStandard.h"
#include "sbndcode/Utilities/SignalShapingServiceSBND.h"
#include "larcore/Geometry/Geometry.h"
#include "lardataobj/Simulation/sim.h"
#include "lardataobj/Simulation/SimChannel.h"
#include "lardataobj/Simulation/SimPhotons.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"

#include "TMath.h"
#include "TComplex.h"
#include "TString.h"
#include "TH2.h"
#include "TH1D.h"
#include "TFile.h"
#include "TRandom.h"
#include "TRandom3.h"
#include "TF1.h"

#include "CLHEP/Random/RandFlat.h"
#include "CLHEP/Random/RandGaussQ.h"
#include "CLHEP/Random/RandExponential.h"

namespace opdet{

class SimPMTSBND;

class SimPMTSBND : public art::EDProducer {
public:
  explicit SimPMTSBND(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  SimPMTSBND(SimPMTSBND const &) = delete;
  SimPMTSBND(SimPMTSBND &&) = delete;
  SimPMTSBND & operator = (SimPMTSBND const &) = delete;
  SimPMTSBND & operator = (SimPMTSBND &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;


private:

  // Declare member data here.
  std::string fInputModuleName;
  double fSampling; //wave sampling frequency (GHz)
  double fReadoutWindow; //waveform time interval (ns)
  unsigned int fNsamples; //Samples per waveform
  double fPreTrigger; //(ns)

  //Single PE peak parameters (multiple gaussian model)
  double fPeakWidth; //time width of each component pulse in ns
  double fPeakDelta; //time difference between two closest component pulses in ns
  double fTransitTime; //to be added to pulse minimum time
  double fTransitSpread;

  TH1D* fTimeProfile; //photons arrival time profile (auxiliary histogram)

  unsigned short SinglePulseType(); //sorts type of PE pulse
  double fDLN; //fraction of prompt double peak PE pulses
  double fTLN; //fraction of prompt triple peak PE pulses
  TF1* fCharge; //auxiliary function to sort PE charge
  TF1* fPulseDLN; //auxiliary function to calculate DLN PE waveform
  TF1* fPulseTLN; //auxiliary function to calculate TLN PE waveform
  double Charge(unsigned short ptype); //sorts PE charge according to PE type
  void AddSPE(size_t time_bin, std::vector<double>& wave); // add single pulse to auxiliary waveform

  double meanDLNQ; //mean DLN charge
  double meanTLNQ; //mean TLN charge
  double meanQ; //mean charge per PE

  std::vector<double> wdln; //DLN pulse vector
  std::vector<double> wtln; //TLN pulse vector
  std::vector<double> wmix; //mix of DLN and TLN pulse vector (for code speed)

  int ndln; //size of DLN waveform
  int ntln; //size of TLN waveform

  double fADC;      //charge to ADC convertion scale
  double fBaseline; //waveform baseline

  double fAmpNoise; //amplitude of gaussian noise

  void AddMixPulse(size_t time_bin, int w, std::vector<double>& wave); //add mixed pulse for time bins with high number of photons (optimization)

  void AddNoise(size_t time_bin, int w, std::vector<double>& wave); //add mixed pulse for time bins with high

  int fOptimize;

};

SimPMTSBND::SimPMTSBND(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{
  // Call appropriate produces<>() functions here.
  produces<std::vector<raw::OpDetWaveform>>();

  fInputModuleName = p.get< std::string >("InputModule" );

  auto const *timeService = lar::providerFrom< detinfo::DetectorClocksService >();
  fSampling = timeService->OpticalClock().Frequency();
  fSampling = 1.0;
  fReadoutWindow = p.get <double>("ReadoutWindow");
  fNsamples = (fReadoutWindow)*fSampling;

  fPeakWidth = p.get <double>("PeakWidth");
  fPeakDelta = p.get <double>("PeakDelta");

  fAmpNoise = 3.0;
  fAmpNoise = p.get <double>("AmpNoise");

//Random number engine initialization
  int seed = time(NULL);
  gRandom = new TRandom3(seed);

  fCharge = new TF1("fCharge","[0]*pow(x,[1])*exp(-x/[2])+[3]*pow(x,[4])*exp(-x/[5])",0.0,30.0);

  fDLN = 0.812;

  double width = fPeakWidth*fSampling;
  double peak = 3.0*width;
  double delta = fPeakDelta*fSampling;

  fTimeProfile = new TH1D("Time Profile", "", fNsamples, 0.0, fNsamples);

  fPulseDLN = new TF1("fPulseDLN", "(1.0/sqrt(2*TMath::Pi()))*([0]/[2]*TMath::Gaus(x,[1],[2])+[3]/[5]*TMath::Gaus(x,[4],[5]))");
  fPulseDLN->SetNpx(1000);
  fPulseDLN->SetParameter(0,0.7);
  fPulseDLN->SetParameter(1,peak);
  fPulseDLN->SetParameter(2,width);
  fPulseDLN->SetParameter(3,0.3);
  fPulseDLN->SetParameter(4,peak+delta);
  fPulseDLN->SetParameter(5,width);

  ndln = peak+4.0*delta;
  wdln.resize(ndln);

  for(int i=0; i<ndln; i++){
	wdln[i]=(fPulseDLN->Eval((double)i)/fSampling);
  }

  fPulseTLN = new TF1("fPulseTLN", "(1.0/sqrt(2.0*TMath::Pi()))*([0]/[2]*TMath::Gaus(x,[1],[2])+[3]/[5]*TMath::Gaus(x,[4],[5])+[6]/[8]*TMath::Gaus(x,[7],[8]))");
  fPulseTLN->SetNpx(1000);
  fPulseTLN->SetParameter(0,0.40);
  fPulseTLN->SetParameter(1,peak);
  fPulseTLN->SetParameter(2,width);
  fPulseTLN->SetParameter(3,0.35);
  fPulseTLN->SetParameter(4,peak+delta);
  fPulseTLN->SetParameter(5,width);
  fPulseTLN->SetParameter(6,0.25);
  fPulseTLN->SetParameter(7,peak+2.0*delta);
  fPulseTLN->SetParameter(8,width);

  ntln = peak+5.0*delta;
  wtln.resize(ntln);
  wmix.resize(ntln);

  TH1D* hQ = new TH1D("hQ","",1000,0.0,300.0);
  for (int i=0; i<1000; i++) {hQ->Fill(Charge(2));}
  meanDLNQ = hQ->GetMean();
  hQ->Reset();

  for(int i=0; i<1000; i++){hQ->Fill(Charge(3));}
  meanTLNQ = hQ->GetMean();
  hQ->Reset();

  meanQ = fDLN*meanDLNQ+(1.0-fDLN)*meanTLNQ;

  for(int i=0; i<ntln; i++){
	wtln[i]=(fPulseTLN->Eval((double)i)/fSampling);
	wmix[i]=fDLN*(fPulseDLN->Eval((double)i)/fSampling)+(1.0-fDLN)*(fPulseTLN->Eval((double)i)/fSampling);
  }

  fTransitTime=54.0; //(ns)
  fADC = -11.1927; //charge to adc factor
  fBaseline = 8000.0;
  fOptimize = 20;

}

void SimPMTSBND::produce(art::Event & e)
{
  std::unique_ptr< std::vector< raw::OpDetWaveform > > pulseVecPtr(std::make_unique< std::vector< raw::OpDetWaveform > > ());

  // Implementation of required member function here.
  std::cout <<"Event: " << e.id().event() << std::endl;

  art::Handle< std::vector<sim::SimPhotons> > pmtHandle;
  e.getByLabel(fInputModuleName, pmtHandle);

  if(!pmtHandle.isValid()){
	std::cout <<Form("Did not find any G4 photons from a producer: %s", "largeant") << std::endl;
  }
  
  std::cout << "Number of photon channels: " << pmtHandle->size() << std::endl;
  unsigned int nChannels = pmtHandle->size();

  std::vector<std::vector<short unsigned int>> waveforms(nChannels,std::vector<short unsigned int> (fNsamples,0));

  std::vector<std::vector<double>> waves(nChannels,std::vector<double>(fNsamples,fBaseline));

  int ch;
  double t_min = 1e15;
  int w;

  for (auto const& simphotons : (*pmtHandle)){
	ch = simphotons.OpChannel();
	if(ch%2 == 0){
	  fTimeProfile->Reset();
          t_min = 1e15;

	  for(size_t i=0; i<simphotons.size(); i++){
		fTimeProfile->Fill(simphotons[i].Time*fSampling);
		if(simphotons[i].Time<t_min) t_min = simphotons[i].Time;
	  }

	  for(int i=1; i<=(int)fNsamples; i++){
		w = fTimeProfile->GetBinContent(i);
		if(w>fOptimize){
		  AddMixPulse(i-1,w,waves[ch]);
		}else{
		  for(int j=0; j<w; j++) AddSPE(i-1,waves[ch]);
		}
		AddNoise(i-1,w,waves[ch]);
 	  }

	  waveforms[ch] = std::vector<short unsigned int> (waves[ch].begin(), waves[ch].end());

	  raw::OpDetWaveform adcVec(t_min+fTransitTime, (unsigned int)ch, waveforms[ch]);
	  pulseVecPtr->emplace_back(std::move(adcVec));
	}
  }

  e.put(std::move(pulseVecPtr));
}

DEFINE_ART_MODULE(SimPMTSBND)

unsigned short SimPMTSBND::SinglePulseType(){

  if(gRandom->Rndm()<fDLN){
	return 2;
  }else{
	return 3;
}
}

double SimPMTSBND::Charge(unsigned short ptype){

  double p1,k1,q1,k2,q2;

  if(ptype==2){

	p1=0.642;
	k1=9.341;
	q1=0.503;
	k2=1.595;
	q2=1.6945;
  }else if(ptype ==3){
	p1=0.549;
	k1=16.666;
	q1=0.317;
	k2=5.185;
	q2=0.721;
  }else if(ptype>3||ptype<2){
	return 0.0;
  }
  
  fCharge->SetParameter(0,p1/(TMath::Gamma(k1)*pow(q1,k1)));
  fCharge->SetParameter(1, k1-1);
  fCharge->SetParameter(2,q1);
  fCharge->SetParameter(3,(1.0-p1)/(TMath::Gamma(k2)*pow(q2,k2)));
  fCharge->SetParameter(4, k2-1.0);
  fCharge->SetParameter(5,q2);

  return fCharge->GetRandom();
}

void SimPMTSBND::AddSPE(size_t time_bin, std::vector<double>& wave){

  unsigned short ptype = SinglePulseType();
  double charge = Charge(ptype);

  size_t min=0;
  size_t max=0;

  if(time_bin<fNsamples){
	min=time_bin;
	if(ptype==2){
	  max=time_bin+ndln < fNsamples ? time_bin+ndln : fNsamples;
	  for(size_t i = min; i<= max; i++){
		wave[i]+= (fADC*charge*wdln[i-min]);	
	  }	
	}
	if(ptype==3){
	  max=time_bin+ntln <fNsamples ? time_bin+ntln : fNsamples;
	  for(size_t i = min; i<= max; i++){
		wave[i]+= (fADC*charge*wtln[i-min]);
	  }	
	}
  }
}

void SimPMTSBND::AddMixPulse(size_t time_bin, int w, std::vector<double>& wave){

  double charge = w*meanQ;

  size_t min = 0;
  size_t max = 0;

  if(time_bin<fNsamples){
	min=time_bin;
	max = time_bin+ntln < fNsamples ? time_bin+ntln :fNsamples;

	for(size_t i = min; i<=max; i++){
	  wave[i] += (fADC*charge*wmix[i-min]);
	}
  }
}

void SimPMTSBND::AddNoise(size_t time_bin, int w, std::vector<double>& wave){

  double aux = 0.0;

  size_t min = 0;
  size_t max = 0;

  if(time_bin<fNsamples){
	min=time_bin;
	max = time_bin+ntln < fNsamples ? time_bin+ntln :fNsamples;

	for(size_t i = min; i<=max; i++){
	  aux = gRandom->Gaus(0,fAmpNoise); //gaussian noise
	  wave[i] += (aux);
	}
  }
}

}
