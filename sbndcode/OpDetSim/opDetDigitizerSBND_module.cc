////////////////////////////////////////////////////////////////////////
// Class:       opDetDigitizerSBND
// Module Type: producer
// File:        opDetDigitizerSBND_module.cc
//
// Generated at Fri Apr  5 09:21:15 2019 by Laura Paulucci Marinho using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "canvas/Utilities/InputTag.h"
#include "canvas/Utilities/Exception.h"
#include "fhiclcpp/types/Atom.h"
#include "fhiclcpp/types/TableFragment.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <vector>
#include <cmath>
#include <string>
#include <map>
#include <unordered_map>
#include <set>
#include <sstream>
#include <fstream>

#include "lardataobj/RawData/OpDetWaveform.h"
#include "lardata/DetectorInfoServices/DetectorClocksServiceStandard.h"
#include "larcore/Geometry/Geometry.h"
#include "lardataobj/Simulation/sim.h"
#include "lardataobj/Simulation/SimChannel.h"
#include "lardataobj/Simulation/SimPhotons.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"

#include "TMath.h"
#include "TH1D.h"
#include "TRandom3.h"
#include "TF1.h"

#include "sbndPDMapAlg.h" 
#include "DigiArapucaSBNDAlg.h" 
#include "DigiPMTSBNDAlg.h" 
#include "opDetSBNDTriggerAlg.h"

namespace opdet{

 /*
 * This module simulates the digitization of SBND photon detectors response.
 * 
 * The module is has an interface to the simulation algorithms for PMTs and arapucas,
 * opdet::DigiPMTSBNDAlg e opdet::DigiArapucaSBNDAlg.
 * 
 * Input
 * ======
 * The module utilizes as input a collection of `sim::SimPhotons` or `sim::SimPhotonsLite`, each
 * containing the photons propagated to a single optical detector channel.
 * 
 * Output
 * =======
 * A collection of optical detector waveforms (`std::vector<raw::OpDetWaveform>`) is produced.
 * 
 * Requirements
 * =============
 * This module currently requires LArSoft services:
 * * `DetectorClocksService` for timing conversions and settings
 * * `LArPropertiesService` for the scintillation yield(s)
 * 
 */

  class opDetDigitizerSBND;

  class opDetDigitizerSBND : public art::EDProducer {
  public:
   struct Config
    {
        using Comment = fhicl::Comment;
        using Name = fhicl::Name;
        
        fhicl::Atom<art::InputTag> InputModuleName {
            Name("InputModule"),
            Comment("Simulated photons to be digitized")
        };
        fhicl::Atom<double> WaveformSize {
            Name("WaveformSize"),
            Comment("Value to initialize the waveform vector in ns. It is resized in the algorithms according to readout window of PDs")
        };
        fhicl::Atom<int> UseLitePhotons {
            Name("UseLitePhotons"),
            Comment("Whether SimPhotonsLite or SimPhotons will be used")
        };
        
        fhicl::TableFragment<opdet::DigiPMTSBNDAlgMaker::Config> pmtAlgoConfig;
        fhicl::TableFragment<opdet::DigiArapucaSBNDAlgMaker::Config> araAlgoConfig;
        fhicl::TableFragment<opdet::opDetSBNDTriggerAlg::Config> trigAlgoConfig;
    }; // struct Config

    using Parameters = art::EDProducer::Table<Config>;

    explicit opDetDigitizerSBND(Parameters const& config);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    opDetDigitizerSBND(opDetDigitizerSBND const &) = delete;
    opDetDigitizerSBND(opDetDigitizerSBND &&) = delete;
    opDetDigitizerSBND & operator = (opDetDigitizerSBND const &) = delete;
    opDetDigitizerSBND & operator = (opDetDigitizerSBND &&) = delete;

    // Required functions.
    void produce(art::Event & e) override;

    opdet::sbndPDMapAlg map; //map for photon detector types
    unsigned int nChannels = map.size();
    unsigned int fNsamples; //Samples per waveform

  private:

  // Declare member data here.
    art::InputTag fInputModuleName;

    double fSampling;       //wave sampling frequency (GHz)
    double fWaveformSize;  //waveform time interval (ns)

    int fUseLitePhotons; //1 for using SimLitePhotons and 0 for SimPhotons (more complete)
    std::unordered_map< raw::Channel_t,std::vector<double> > fFullWaveforms;  


    void CreateDirectPhotonMap(std::map<int,sim::SimPhotons>& auxmap, std::vector< art::Handle< std::vector< sim::SimPhotons > > > photon_handles);
    void CreateDirectPhotonMapLite(std::map<int,sim::SimPhotonsLite>& auxmap, std::vector< art::Handle< std::vector< sim::SimPhotonsLite > > > photon_handles);

    void MakeWaveforms(const art::Event &e, opdet::DigiPMTSBNDAlg *pmtDigitizer, opdet::DigiArapucaSBNDAlg *arapucaDigitizer, 
         std::vector< raw::OpDetWaveform > *pulseVecPtr,
         bool make_triggers, bool apply_triggers, bool save_waveforms);

//arapuca and PMT digitization algorithms
    opdet::DigiPMTSBNDAlgMaker makePMTDigi;
    opdet::DigiArapucaSBNDAlgMaker makeArapucaDigi;

    // trigger algorithm
    opdet::opDetSBNDTriggerAlg fTriggerAlg;
  };

  opDetDigitizerSBND::opDetDigitizerSBND(Parameters const& config)
  : EDProducer{config}
  , fInputModuleName(config().InputModuleName())
  , fWaveformSize(config().WaveformSize())
  , fUseLitePhotons(config().UseLitePhotons())
  , makePMTDigi(config().pmtAlgoConfig())
  , makeArapucaDigi(config().araAlgoConfig())
  , fTriggerAlg(config().trigAlgoConfig(), lar::providerFrom<detinfo::DetectorClocksService>(), lar::providerFrom<detinfo::DetectorPropertiesService>())
  {
  // Call appropriate produces<>() functions here.
    produces< std::vector< raw::OpDetWaveform > >();

    auto const *timeService = lar::providerFrom< detinfo::DetectorClocksService >();
    fSampling = (timeService->OpticalClock().Frequency())*500/64/1000.0; //in GHz
  
    std::cout << "Sampling = " << fSampling << " GHz." << std::endl;
  
    fNsamples = (int)(fWaveformSize*fSampling);
  }

  void opDetDigitizerSBND::produce(art::Event & e)
  {
    std::unique_ptr< std::vector< raw::OpDetWaveform > > pulseVecPtr(std::make_unique< std::vector< raw::OpDetWaveform > > ());
  // Implementation of required member function here.
    std::cout <<"Event: " << e.id().event() << std::endl;

    // prepare the algorithm
    //     
    auto arapucaDigitizer = makeArapucaDigi(
    *(lar::providerFrom<detinfo::LArPropertiesService>()),
    *(lar::providerFrom<detinfo::DetectorClocksService>())
    );

    auto pmtDigitizer = makePMTDigi(
    *(lar::providerFrom<detinfo::LArPropertiesService>()),
    *(lar::providerFrom<detinfo::DetectorClocksService>())
    );

    // first run the digitizer to make triggers
    MakeWaveforms(e, pmtDigitizer.get(), arapucaDigitizer.get(), pulseVecPtr.get(), true, false, false);

    // combine the triggers
    fTriggerAlg.MergeTriggerLocations();

    // run the digitizer again -- apply the triggers and save the waveforms
    MakeWaveforms(e, pmtDigitizer.get(), arapucaDigitizer.get(), pulseVecPtr.get(), false, true, true); 

    // put the waveforms in the event
    e.put(std::move(pulseVecPtr));

  }//produce end

  void opDetDigitizerSBND::MakeWaveforms(const art::Event &e, opdet::DigiPMTSBNDAlg *pmtDigitizer, opdet::DigiArapucaSBNDAlg *arapucaDigitizer, 
    std::vector< raw::OpDetWaveform > *pulseVecPtr,
    bool make_triggers, bool apply_triggers, bool save_waveforms) 
  {
    int ch, channel;
    double t_min;
    if(fUseLitePhotons==1){//using SimPhotonsLite

      std::vector<std::vector<short unsigned int>> waveforms(nChannels,std::vector<short unsigned int> (fNsamples,0));
 
      std::map<int,sim::SimPhotonsLite> auxmap;   // to temporarily store channel and combine PMT (direct and converted) time profiles
 
     //Get *ALL* SimPhotonsCollectionLite from Event
      std::vector< art::Handle< std::vector< sim::SimPhotonsLite > > > photon_handles;
      e.getManyByType(photon_handles);
      if (photon_handles.size() == 0)
        throw art::Exception(art::errors::ProductNotFound)<<"sim SimPhotonsLite retrieved and you requested them.";
      
      CreateDirectPhotonMapLite(auxmap, photon_handles);

      for (auto opdetHandle: photon_handles) {
 
      //this now tells you if light collection is reflected
        bool Reflected = (opdetHandle.provenance()->productInstanceName() == "Reflected");
      
        std::cout << "Number of photon channels: " << opdetHandle->size() << std::endl;

        for (auto const& litesimphotons : (*opdetHandle)){
	  ch = litesimphotons.OpChannel;
	  t_min=1e15;
          raw::OpDetWaveform adcVec;
          raw::ADC_Count_t baseline = 0;
	  if((Reflected) && (map.pdType(ch, "barepmt") || map.pdType(ch, "pmt") )){ //All PMT channels
	//    std::cout << ch << " : PMT channel " <<std::endl;
	    pmtDigitizer->ConstructWaveformLite(ch, litesimphotons, waveforms, map.pdName(ch), auxmap, t_min);
	    adcVec = raw::OpDetWaveform(t_min, (unsigned int)ch, waveforms[ch]);//including pre trigger window and transit time
            baseline = (int)pmtDigitizer->Baseline();
	  }
/*	  if(map.pdType(ch, "bar")) //Paddles
	    std::cout << ch << " : Digitization not implemented for paddles. " <<std::endl;*/
	  else if((map.pdType(ch, "arapucaT1") && !Reflected) || (map.pdType(ch, "arapucaT2") && Reflected) ){//getting only arapuca channels with appropriate type of light
//	    std::cout << "Arapuca channels " <<std::endl;
	    arapucaDigitizer->ConstructWaveformLite(ch, litesimphotons, waveforms, map.pdName(ch),t_min);
            adcVec = raw::OpDetWaveform(t_min, (unsigned int)ch, waveforms[ch]);//including pre trigger window and transit time
            baseline = (int)arapucaDigitizer->Baseline();
          }
	  else if((map.pdType(ch,"xarapucaprime") && !Reflected)){//getting only xarapuca channels with appropriate type of light (this separation is needed because xarapucas are set as two different optical channels but are actually only one readout channel)
	//    std::cout << "X-Arapuca channels " <<std::endl;
            sim::SimPhotonsLite auxLite;
            for (auto const& litesimphotons : (*opdetHandle)){
              channel = litesimphotons.OpChannel;
              if(channel==ch) auxLite =(litesimphotons);
              if(channel==(ch+2)) auxLite+=(litesimphotons);
 	    }
	    arapucaDigitizer->ConstructWaveformLite(ch, auxLite, waveforms, map.pdName(ch),t_min);
            adcVec = raw::OpDetWaveform(t_min, (unsigned int)ch, waveforms[ch]);//including pre trigger window and transit time
            baseline = (int)arapucaDigitizer->Baseline();
          }
          // make triggers if configured to
          if (make_triggers) {
            fTriggerAlg.FindTriggerLocations(adcVec, baseline);
          }
          // saving waveform
          if (save_waveforms) {
            if (apply_triggers) {
              std::vector<raw::OpDetWaveform> waveforms = fTriggerAlg.ApplyTriggerLocations(adcVec);
              // move these waveforms into the pulseVecPtr
              pulseVecPtr->reserve(pulseVecPtr->size() + waveforms.size());
              std::move(waveforms.begin(), waveforms.end(), std::back_inserter(*pulseVecPtr));
            }
            else {
              pulseVecPtr->emplace_back(std::move(adcVec));
            }
          }
        }
      }  //end loop on simphoton lite collections
    }else{ //for SimPhotons

      std::vector<std::vector<short unsigned int>> waveforms(nChannels,std::vector<short unsigned int> (fNsamples,0));
//      std::vector<std::vector<double>> waves(nChannels,std::vector<double>(fNsamples,fBaseline));

      std::map<int,sim::SimPhotons> auxmap;   // to temporarily store channel and direct light distribution
      //Get *ALL* SimPhotonsCollection from Event
      std::vector< art::Handle< std::vector< sim::SimPhotons > > > photon_handles;
      e.getManyByType(photon_handles);
      if (photon_handles.size() == 0)
	throw art::Exception(art::errors::ProductNotFound)<<"sim SimPhotons retrieved and you requested them.";
      
      CreateDirectPhotonMap(auxmap, photon_handles);
 
      for (auto opdetHandle: photon_handles) {
        bool Reflected = (opdetHandle.provenance()->productInstanceName() == "Reflected");

        std::cout << "Number of photon channels: " << opdetHandle->size() << std::endl;

        for (auto const& simphotons : (*opdetHandle)){
	  ch = simphotons.OpChannel();
	  t_min=1e15;
          raw::OpDetWaveform adcVec;
          raw::ADC_Count_t baseline = 0;
	  if((Reflected) && (map.pdType(ch, "barepmt") || map.pdType(ch,"pmt"))){ //all PMTs
//	    std::cout << "PMT channels " <<std::endl;
	    pmtDigitizer->ConstructWaveform(ch, simphotons, waveforms, map.pdName(ch), auxmap, t_min);
            adcVec = raw::OpDetWaveform(t_min, (unsigned int)ch, waveforms[ch]);//including pre trigger window and transit time
            baseline = (int)pmtDigitizer->Baseline();
          }
/*	  if(map.pdType(ch, "bar")) //Paddles
	    std::cout << "Digitization not implemented for paddles. " <<std::endl;*/
	  if((map.pdType(ch, "arapucaT1") && !Reflected) || (map.pdType(ch, "arapucaT2") && Reflected) ){//getting only arapuca channels with appropriate type of light
//	    std::cout << "Arapuca channels " <<std::endl;
	    arapucaDigitizer->ConstructWaveform(ch, simphotons, waveforms, map.pdName(ch),t_min);
            adcVec = raw::OpDetWaveform(t_min, (unsigned int)ch, waveforms[ch]);//including pre trigger window and transit time
            baseline = (int)arapucaDigitizer->Baseline();
          }
	  if((map.pdType(ch,"xarapucaprime") && !Reflected)){//getting only xarapuca channels with appropriate type of light (this separation is needed because xarapucas are set as two different optical channels but are actually only one readout channel)
//	    std::cout << "X-Arapuca channels " <<std::endl;
            sim::SimPhotons auxPhotons;
            for (auto const& simphotons : (*opdetHandle)){
              channel= simphotons.OpChannel();
              if(channel==ch) auxPhotons =(simphotons);
              if(channel==(ch+2)) auxPhotons+=(simphotons);
 	    }
	    arapucaDigitizer->ConstructWaveform(ch, auxPhotons, waveforms, map.pdName(ch),t_min);
            adcVec = raw::OpDetWaveform(t_min, (unsigned int)ch, waveforms[ch]);//including pre trigger window and transit time
            baseline = (int)arapucaDigitizer->Baseline();
          }
          // make triggers if configured to
          if (make_triggers) {
            fTriggerAlg.FindTriggerLocations(adcVec, baseline);
          }
          // saving waveform
          if (save_waveforms) {
            if (apply_triggers) {
              std::vector<raw::OpDetWaveform> waveforms = fTriggerAlg.ApplyTriggerLocations(adcVec);
              // move these waveforms into the pulseVecPtr
              pulseVecPtr->reserve(pulseVecPtr->size() + waveforms.size());
              std::move(waveforms.begin(), waveforms.end(), std::back_inserter(*pulseVecPtr));
            }
            else {
              pulseVecPtr->emplace_back(std::move(adcVec));
            }
          }
        }//optical channel loop
      }//type of light loop
    }//simphotons end
  }

  DEFINE_ART_MODULE(opdet::opDetDigitizerSBND)

  void opDetDigitizerSBND::CreateDirectPhotonMap(std::map<int,sim::SimPhotons>& auxmap, std::vector< art::Handle< std::vector< sim::SimPhotons > > > photon_handles)
  {
    int ch;
    // Loop over direct/reflected photons
    for (auto pmtHandle: photon_handles) {
       // Do some checking before we proceed
        if (!pmtHandle.isValid()) continue;  
        if (pmtHandle.provenance()->moduleLabel() != fInputModuleName) continue;   //not the most efficient way of doing this, but preserves the logic of the module. Andrzej
      //this now tells you if light collection is reflected
      bool Reflected = (pmtHandle.provenance()->productInstanceName() == "Reflected");
      
      for (auto const& simphotons : (*pmtHandle)){
	  ch = simphotons.OpChannel();
	  if(map.pdType(ch, "pmt") && !Reflected)
            auxmap.insert(std::make_pair(ch,simphotons));
      }
    }
  }

  void opDetDigitizerSBND::CreateDirectPhotonMapLite(std::map<int,sim::SimPhotonsLite>& auxmap, std::vector< art::Handle< std::vector< sim::SimPhotonsLite > > > photon_handles)
  {
    int ch;
    // Loop over direct/reflected photons
    for (auto pmtHandle: photon_handles) {
       // Do some checking before we proceed
        if (!pmtHandle.isValid()) continue;  
        if (pmtHandle.provenance()->moduleLabel() != fInputModuleName) continue;   //not the most efficient way of doing this, but preserves the logic of the module. Andrzej
      //this now tells you if light collection is reflected
      bool Reflected = (pmtHandle.provenance()->productInstanceName() == "Reflected");
      
      for (auto const& litesimphotons : (*pmtHandle)){
	  ch = litesimphotons.OpChannel;
	  if(map.pdType(ch, "pmt") && !Reflected)
            auxmap.insert(std::make_pair(ch,litesimphotons));
      }
    }
  }

}//closing namespace
