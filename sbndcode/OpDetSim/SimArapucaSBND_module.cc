////////////////////////////////////////////////////////////////////////
// Class:       SimArapucaSBND
// Module Type: producer
// File:        SimArapucaSBND_module.cc
//
// This module produces the electronics response of arapucas
// Created by L. Paulucci and F. Marinho
// Based on OpDetDigitizerDUNE_module.cc and SimPMTSBND_module.cc
////////////////////////////////////////////////////////////////////////

#include "canvas/Utilities/Exception.h"
#include "canvas/Utilities/InputTag.h"
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <vector>
#include <cmath>
#include <string>
#include <map>
#include <unordered_map>
#include <set>
#include <sstream>
#include <fstream>

#include "lardataobj/RawData/OpDetWaveform.h"
#include "lardata/DetectorInfoServices/DetectorClocksServiceStandard.h"
#include "larcore/Geometry/Geometry.h"
#include "lardataobj/Simulation/sim.h"
#include "lardataobj/Simulation/SimChannel.h"
#include "lardataobj/Simulation/SimPhotons.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"

#include "TMath.h"
#include "TH1D.h"
#include "TRandom3.h"
#include "TF1.h"

#include "sbndPDMapAlg.h" 

namespace opdet{

  class SimArapucaSBND;

  class SimArapucaSBND : public art::EDProducer {
  public:
    explicit SimArapucaSBND(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
    SimArapucaSBND(SimArapucaSBND const &) = delete;
    SimArapucaSBND(SimArapucaSBND &&) = delete;
    SimArapucaSBND & operator = (SimArapucaSBND const &) = delete;
    SimArapucaSBND & operator = (SimArapucaSBND &&) = delete;

  // Required functions.
    void produce(art::Event & e) override;

    opdet::sbndPDMapAlg map; //map for photon detector types
    unsigned int nChannels = map.size();

  private:

  // Declare member data here.
    std::string fInputModuleName;
    double fSampling;        //wave sampling frequency (GHz)
    double fReadoutWindow;   //waveform time interval (ns)
    unsigned int fNsamples;  //Samples per waveform
    double fPreTrigger;      //(ns)
 
  //Single PE peak parameters 
    double fPeakTime;      // maximum time of each component pulse in ns
    double fPulseLength;   // in ns
    double fMaxAmplitude;  // Maximum amplitude for pulses in mV
    double fFrontTime;     // pulse rising time constant (exponential)
    double fBackTime;      // pulse decaying time constant (exponential)
    int pulsesize;
  
    double fADC;            //voltage to ADC convertion scale
    double fBaseline;       //waveform baseline
    double fBaselineRMS;    //Pedestal RMS in ADC counts
    double fDarkNoiseRate;  //in Hz
    double fCrossTalk;      //probability for producing a signal of 2 PE in response to 1 photon
    double fSaturation;     //Saturation in number of p.e.
    double fQE;             //SiPM quantum efficiency
    int fUseLitePhotons;    //1 for using SimLitePhotons and 0 for SimPhotons (more complete)
    double fArapucaEffT1;   //Arapuca type 1 efficiency (optical window + cavity)
    double fArapucaEffT2;   //Arapuca type 2 efficiency (optical window + cavity)
    double fArapucaEffx;   //X-Arapuca efficiency (optical window + cavity)

    TH1D* TimeArapucaT1; //histogram for getting the photon time distribution inside the arapuca T1 box (considering the optical window)
    TH1D* TimeArapucaT2; //histogram for getting the photon time distribution inside the arapuca T2 box (considering the optical window)
  
    std::vector<double> wsp; //single photon pulse vector
    std::unordered_map< raw::Channel_t,std::vector<double> > fFullWaveforms;
    
    void AddSPE(size_t time_bin, std::vector<double>& wave, int nphotons); // add single pulse to auxiliary waveform
    double Pulse1PE(double time) const;
    void AddLineNoise(std::vector<double>& wave);
    void AddDarkNoise(std::vector<double>& wave);
    double FindMinimumTime(sim::SimPhotons const& simphotons);
    double FindMinimumTimeLite(std::map< int, int > const& photonMap);  
    void CreatePDWaveform(sim::SimPhotons const& SimPhotons, double t_min, std::vector<double>& wave, std::string pdtype);
    void CreatePDWaveformLite(std::map< int, int > const& photonMap, double t_min, std::vector<double>& wave, std::string pdtype); 
    void CreateSaturation(std::vector<double>& wave);//Including saturation effects
  };

  SimArapucaSBND::SimArapucaSBND(fhicl::ParameterSet const & p)
// : 
// Initialize member data here.
  {
    // Reading the fcl file
    fInputModuleName    = p.get< std::string >("InputModule" );
    fADC                = p.get< double >("VoltageToADC"     );
    fBaselineRMS        = p.get< double >("BaselineRMS"      );
    fDarkNoiseRate      = p.get< double >("DarkNoiseRate"    );
    fCrossTalk          = p.get< double >("CrossTalk"        );
    fBaseline           = p.get< double >("Baseline"         );
    fReadoutWindow      = p.get< double >("ReadoutWindow"    );
    fPulseLength        = p.get< double >("PulseLength"      );
    fPeakTime           = p.get< double >("PeakTime"         );
    fMaxAmplitude       = p.get< double >("MaxAmplitude"     );
    fFrontTime          = p.get< double >("FrontTime"        );
    fBackTime           = p.get< double >("BackTime"         );
    fPreTrigger         = p.get< double >("PreTrigger"       );
    fSaturation         = p.get< double >("Saturation"       );
    fUseLitePhotons     = p.get< int    >("UseLitePhotons"   ); //whether SimPhotonsLite or SimPhotons will be used
    double AraEffT1     = p.get< double >("ArapucaEffT1"     );
    double AraEffT2     = p.get< double >("ArapucaEffT2"     );
    double AraEffx      = p.get< double >("ArapucaEffx"     );

//Correction due to scalling factor applied during simulation
    auto const *LarProp = lar::providerFrom<detinfo::LArPropertiesService>();
    fArapucaEffT1 = AraEffT1/(LarProp->ScintPreScale());  
    fArapucaEffT2 = AraEffT2/(LarProp->ScintPreScale());
    fArapucaEffx  = AraEffx/(LarProp->ScintPreScale());

    std::cout << "arapucas corrected efficiencies = " << fArapucaEffT1 << ", " << fArapucaEffT2 << " and " << fArapucaEffx << std::endl;

    if(fArapucaEffT1>1.0001 || fArapucaEffT2>1.0001 || fArapucaEffx>1.0001)
	std::cout << "WARNING: Quantum efficiency set in fhicl file " << AraEffT1 << " or " << AraEffT2 << " or " << AraEffx << " seems to be too large! Final QE must be equal to or smaller than the scintillation pre scale applied at simulation time. Please check this number (ScintPreScale): " << LarProp->ScintPreScale() << std::endl;

  // Call appropriate produces<>() functions here.

    produces<std::vector<raw::OpDetWaveform>>();

    auto const *timeService = lar::providerFrom< detinfo::DetectorClocksService >();
    fSampling = (timeService->OpticalClock().Frequency())/1000.0; //in GHz

    std::cout << "Sampling = " << fSampling << std::endl;
    fNsamples = (int)((fPreTrigger+fReadoutWindow)*fSampling); //number of ticks in the waveform

    TimeArapucaT1 = new TH1D("Time Profile T1", "", 150, 0.0, 150.0);//histogram that stores the arrival time of photons at SiPM (t=0 is the time is reaches the outside of the optical window) for arapuca T1

    double x[150] = {374, 1455, 2002, 2230, 2336, 2296, 2087, 2006, 1831, 1716, 1623, 1553, 1437, 1327, 1348, 1260, 1237, 1234, 1164, 1122, 1070, 1092, 993, 1002, 892, 969, 951, 907, 909, 961, 863, 857, 915, 900, 853, 842, 790, 780, 779, 808, 781, 749, 723, 737, 723, 755, 732, 680, 724, 631, 656, 693, 669, 632, 636, 643, 632, 640, 608, 615, 597, 633, 602, 545, 591, 595, 551, 574, 567, 507, 545, 535, 552, 519, 537, 563, 523, 461, 550, 510, 514, 469, 517, 493, 466, 460, 488, 446, 474, 516, 451, 451, 457, 465, 450, 456, 493, 441, 441, 475, 433, 419, 435, 405, 392, 410, 430, 404, 392, 407, 435, 411, 383, 422, 394, 397, 413, 366, 389, 376, 366, 372, 375, 345, 370, 368, 370, 390, 351, 382, 373, 380, 377, 339, 372, 371, 351, 360, 338, 365, 309, 187, 95, 41, 19, 7, 2, 3, 0, 0};
 
    for(size_t i=1; i<150; i++)TimeArapucaT1->SetBinContent(i,x[i]);

    TimeArapucaT2 = new TH1D("Time Profile T1", "", 90, 0.0, 90.0);//histogram that stores the arrival time of photons at SiPM (t=0 is the time is reaches the outside of the optical window) for arapuca T2
 
    double x2[90]={5051, 8791, 9054, 8777, 8045, 7009, 6304, 5637, 4828, 4320, 3821, 3333, 2968, 2629, 2364, 2060, 1786, 1624, 1368, 1174, 1115, 935, 820, 725, 627, 535, 500, 453, 386, 355, 315, 279, 221, 196, 198, 181, 120, 115, 128, 109, 79, 67, 77, 59, 48, 39, 40, 37, 32, 39, 22, 25, 18, 20, 14, 19, 8, 9, 6, 11, 13, 4, 11, 4, 4, 5, 3, 2, 4, 4, 5, 2, 6, 0, 0, 2, 1, 0, 0, 0, 1, 2, 1, 0, 0, 1, 0, 1, 0, 0};

    for(size_t i=1; i<90; i++)TimeArapucaT2->SetBinContent(i,x2[i]);

//Random number engine initialization
    int seed = time(NULL);
    gRandom = new TRandom3(seed);

    pulsesize=fPulseLength*fSampling;
    wsp.resize(pulsesize);

    for(int i=0; i<pulsesize; i++)
	wsp[i]=(Pulse1PE(static_cast< double >(i)/fSampling));
	//std::cout << wsp[i] << std::endl;
  }

  void SimArapucaSBND::produce(art::Event & e)
  {

    std::unique_ptr< std::vector< raw::OpDetWaveform > > pulseVecPtr(std::make_unique< std::vector< raw::OpDetWaveform > > ());

  // Implementation of required member function here.
    std::cout <<"Event: " << e.id().event() << std::endl;

    int ch, channel;
    double t_min = 1e15;

    if(fUseLitePhotons==1){//using SimPhotonsLite

      std::vector<std::vector<short unsigned int>> waveforms(nChannels,std::vector<short unsigned int> (fNsamples,0));
      std::vector<std::vector<double>> waves(nChannels,std::vector<double>(fNsamples,fBaseline));
      //Get *ALL* SimPhotonsCollectionLite from Event
      std::vector< art::Handle< std::vector< sim::SimPhotonsLite > > > photon_handles;
      e.getManyByType(photon_handles);
      if (photon_handles.size() == 0)
        throw art::Exception(art::errors::ProductNotFound)<<"sim SimPhotonsLite retrieved and you requested them.";
      
     // Loop over direct/reflected photons
      for (auto opHandle: photon_handles) {
          // Do some checking before we proceed
        if (!opHandle.isValid()) continue;  
        if (opHandle.provenance()->moduleLabel() != fInputModuleName) continue;   //not the most efficient way of doing this, but preserves the logic of the module. Andrzej
 
      //this now tells you if light collection is reflected
        bool Reflected = (opHandle.provenance()->productInstanceName() == "Reflected");
      
        if(Reflected)
	  {std::cout << "looking at reflected/visible lite photons" << std::endl; }
        else
	  {std::cout << "looking at direct/vuv lite photons" << std::endl;  }  	  
	  
        std::cout << "Number of photon channels: " << opHandle->size() << std::endl;
      
        for (auto const& litesimphotons : (*opHandle)){
	  ch = litesimphotons.OpChannel;
          t_min=1e15;
	  if((map.pdType(ch, "arapucaT1") && !Reflected) || (map.pdType(ch, "arapucaT2") && Reflected)){//getting only arapuca channels with appropriate type of light
  	    std::map< int, int > const& photonMap = litesimphotons.DetectedPhotons;
  	    t_min=FindMinimumTimeLite(photonMap);
	    CreatePDWaveformLite(photonMap, t_min, waves[ch], map.pdName(ch));
	    waveforms[ch] = std::vector<short unsigned int> (waves[ch].begin(), waves[ch].end());
	    raw::OpDetWaveform adcVec(t_min, (unsigned int)ch, waveforms[ch]);//including pre trigger window and transit time
	    pulseVecPtr->emplace_back(std::move(adcVec));  
	  }
	  if((map.pdType(ch,"xarapucaprime") && !Reflected)){//getting only xarapuca channels with appropriate type of light (this separation is needed because xarapucas are set as two different optical channels but are actually only one readout channel)
            sim::SimPhotonsLite auxLite;
            for (auto const& litesimphotons : (*opHandle)){
              channel= litesimphotons.OpChannel;
              if(channel==ch){
                auxLite =(litesimphotons);
              }
              if(channel==(ch+2)){
                auxLite+=(litesimphotons);
              }
 	    }
  	    std::map< int, int > const& photonMap = auxLite.DetectedPhotons;
  	    t_min=FindMinimumTimeLite(photonMap);
  	    CreatePDWaveformLite(photonMap, t_min, waves[ch], map.pdName(ch));
	    waveforms[ch] = std::vector<short unsigned int> (waves[ch].begin(), waves[ch].end());
	    raw::OpDetWaveform adcVec(t_min, (unsigned int)ch, waveforms[ch]);//including pre trigger window and transit time
	    pulseVecPtr->emplace_back(std::move(adcVec));
	  }
        }
       }  //end loop on simphoton lite collections
    e.put(std::move(pulseVecPtr));
    }else{ //for SimPhotons
      std::vector<std::vector<short unsigned int>> waveforms(nChannels,std::vector<short unsigned int> (fNsamples,0));
      std::vector<std::vector<double>> waves(nChannels,std::vector<double>(fNsamples,fBaseline));
      //Get *ALL* SimPhotonsCollection from Event
      std::vector< art::Handle< std::vector< sim::SimPhotons > > > photon_handles;
      e.getManyByType(photon_handles);
      if (photon_handles.size() == 0)
	throw art::Exception(art::errors::ProductNotFound)<<"sim SimPhotons retrieved and you requested them.";
      
      // Loop over direct/reflected photons
      for (auto opHandle: photon_handles) {
       // Do some checking before we proceed
        if (!opHandle.isValid()) continue;  
        if (opHandle.provenance()->moduleLabel() != fInputModuleName) continue;   //not the most efficient way of doing this, but preserves the logic of the module. Andrzej
 
      //this now tells you if light collection is reflected
        bool Reflected = (opHandle.provenance()->productInstanceName() == "Reflected");
      
       if(Reflected)
	  {std::cout << "looking at reflected/visible photons" << std::endl; }
	  else
	  {std::cout << "looking at direct/vuv photons" << std::endl;  }  
	
      std::cout << "Number of photon channels: " << opHandle->size() << std::endl;

      for (auto const& simphotons : (*opHandle)){
	ch = simphotons.OpChannel();
	t_min=1e15;

	if((map.pdType(ch, "arapucaT1") && !Reflected) || (map.pdType(ch, "arapucaT2") && Reflected)){//getting only arapuca channels with appropriate type of light
  	  t_min=FindMinimumTime(simphotons);
	  CreatePDWaveform(simphotons, t_min, waves[ch], map.pdName(ch));
 	  waveforms[ch] = std::vector<short unsigned int> (waves[ch].begin(), waves[ch].end());
	  raw::OpDetWaveform adcVec(t_min, (unsigned int)ch, waveforms[ch]);//including pre trigger window and transit time
	  pulseVecPtr->emplace_back(std::move(adcVec));
	}
	if((map.pdType(ch,"xarapucaprime") && !Reflected)){//getting only xarapuca channels with appropriate type of light (this separation is needed because xarapucas are set as two different optical channels but are actually only one readout channel)
          sim::SimPhotons auxPhotons;
          for (auto const& simphotons : (*opHandle)){
            channel= simphotons.OpChannel();
            if(channel==ch){
              auxPhotons =(simphotons);
            }
            if(channel==(ch+2)){
              auxPhotons+=(simphotons);
            }
 	  }
  	  t_min=FindMinimumTime(auxPhotons);
	  CreatePDWaveform(auxPhotons, t_min, waves[ch], map.pdName(ch));
 	  waveforms[ch] = std::vector<short unsigned int> (waves[ch].begin(), waves[ch].end());
	  raw::OpDetWaveform adcVec(t_min, (unsigned int)ch, waveforms[ch]);//including pre trigger window and transit time
	  pulseVecPtr->emplace_back(std::move(adcVec));
        }
      }
    }  //end loop on photon collections.
    e.put(std::move(pulseVecPtr));
    }
  }

  DEFINE_ART_MODULE(SimArapucaSBND)


  void SimArapucaSBND::AddSPE(size_t time_bin, std::vector<double>& wave, int nphotons){//adding single pulse

    size_t min=0, max=0;

    if(time_bin<fNsamples){
	min=time_bin;
	max=time_bin+pulsesize < fNsamples ? time_bin+pulsesize : fNsamples;
	for(size_t i = min; i<= max; i++){
		wave[i]+= (wsp[i-min])*(double)nphotons;	
	}		
    }
  }

  double SimArapucaSBND::Pulse1PE(double time) const//single pulse waveform
  {
    if (time < fPeakTime) return (fADC*fMaxAmplitude*std::exp((time - fPeakTime)/fFrontTime));
    else return (fADC*fMaxAmplitude*std::exp(-(time - fPeakTime)/fBackTime));
  }

  void SimArapucaSBND::AddLineNoise(std::vector< double >& wave)
  {
    double noise;
    for(size_t i = 0; i < wave.size(); i++){
        noise= gRandom->Gaus(0, fBaselineRMS); //gaussian baseline noise  
        wave[i] += noise; 
    }
  }

  void SimArapucaSBND::AddDarkNoise(std::vector< double >& wave)
  {
    int nCT;

    // Multiply by 10^9 since fDarkNoiseRate is in Hz (conversion from s to ns)
    double darkNoiseTime = static_cast< double >(gRandom->Exp((1.0/fDarkNoiseRate)*1000000000.0));
    while (darkNoiseTime < wave.size()){
	size_t timeBin = (darkNoiseTime);
	  if(fCrossTalk>0.0 && (gRandom->Uniform(1.0))<fCrossTalk) nCT=2;
	  else nCT=1;
	  AddSPE(timeBin,wave,nCT);
        // Find next time to add dark noise
        darkNoiseTime += static_cast< double >(gRandom->Exp((1.0/fDarkNoiseRate)*1000000000.0));
    }
  }

  double SimArapucaSBND::FindMinimumTime(sim::SimPhotons const& simphotons){
    double t_min=1e15;
      for(size_t i=0; i<simphotons.size(); i++){	 	 
      	if(simphotons[i].Time<t_min) t_min = simphotons[i].Time;
      }
    return t_min;
  }

  void SimArapucaSBND::CreatePDWaveform(sim::SimPhotons const& simphotons, double t_min, std::vector<double>& wave, std::string pdtype){

    int nCT=1;
    double tphoton=0;
    if(pdtype=="arapucaT1"){
	for(size_t i=0; i<simphotons.size(); i++){
	  if((gRandom->Uniform(1.0))<fArapucaEffT1){ //Sample a random subset according to Arapuca's efficiency
	    tphoton=simphotons[i].Time;
	    tphoton+=(TimeArapucaT1->GetRandom());
	    tphoton+=(fPreTrigger-t_min);
 	    if(fCrossTalk>0.0 && (gRandom->Uniform(1.0))<fCrossTalk) nCT=2;
	    else nCT=1;
	    AddSPE(tphoton*fSampling,wave,nCT);
	  }
	}
    }
    if(pdtype=="arapucaT2"){   
	for(size_t i=0; i<simphotons.size(); i++){
 	  if((gRandom->Uniform(1.0))<fArapucaEffT2){ //Sample a random subset according to Arapuca's efficiency.
	    tphoton=simphotons[i].Time;
  	    tphoton+=(TimeArapucaT2->GetRandom());
	    tphoton+=(fPreTrigger-t_min);
 	    if(fCrossTalk>0.0 && (gRandom->Uniform(1.0))<fCrossTalk) nCT=2;
	    else nCT=1;
	    AddSPE(tphoton*fSampling,wave,nCT);
	  }
	}
    }
    if(pdtype=="xarapucaprime"){   
	for(size_t i=0; i<simphotons.size(); i++){
 	  if((gRandom->Uniform(1.0))<fArapucaEffx){ 
	    tphoton=simphotons[i].Time;
 	    tphoton+=(TimeArapucaT1->GetRandom());//PROPER TIMING YET TO BE IMPLEMENTED FOR X-ARAPUCA
	    tphoton+=(fPreTrigger-t_min);
 	    if(fCrossTalk>0.0 && (gRandom->Uniform(1.0))<fCrossTalk) nCT=2;
	    else nCT=1;
	    AddSPE(tphoton*fSampling,wave,nCT);
	  }
	}
    }

    if(fBaselineRMS>0.0) AddLineNoise(wave);
    if(fDarkNoiseRate > 0.0) AddDarkNoise(wave);
    CreateSaturation(wave);
  }

  void SimArapucaSBND::CreateSaturation(std::vector<double>& wave){ //Implementing saturation effects

    for(size_t k=0; k<fNsamples; k++){
	if(wave[k]>(fBaseline+fSaturation*fADC*fMaxAmplitude))
	  wave[k]=fBaseline+fSaturation*fADC*fMaxAmplitude;	  
    }
  }

  void SimArapucaSBND::CreatePDWaveformLite(std::map< int, int > const& photonMap, double t_min, std::vector<double>& wave, std::string pdtype){

    double tphoton=0;
    int nCT=1;
    for (auto const& mapMember: photonMap){
      for(int i=0; i<mapMember.second; i++){
         if(pdtype=="arapucaT1" && (gRandom->Uniform(1.0))<fArapucaEffT1){
  	    tphoton=(TimeArapucaT1->GetRandom());
 	    tphoton+=mapMember.first+fPreTrigger-t_min;
 	    if(fCrossTalk>0.0 && (gRandom->Uniform(1.0))<fCrossTalk) nCT=2;
	    else nCT=1;
	    AddSPE(tphoton*fSampling,wave,nCT);
         }
         if(pdtype=="arapucaT2" && (gRandom->Uniform(1.0))<fArapucaEffT2){
  	    tphoton=(TimeArapucaT2->GetRandom());
 	    tphoton+=mapMember.first+fPreTrigger-t_min;
 	    if(fCrossTalk>0.0 && (gRandom->Uniform(1.0))<fCrossTalk) nCT=2;
	    else nCT=1;
	    AddSPE(tphoton*fSampling,wave,nCT);
         }
	if(pdtype=="xarapucaprime" && (gRandom->Uniform(1.0))<fArapucaEffx){
	   tphoton=(TimeArapucaT1->GetRandom()); //TO BE CORRECTED LATER
	   tphoton+=mapMember.first+fPreTrigger-t_min;
 	   if(fCrossTalk>0.0 && (gRandom->Uniform(1.0))<fCrossTalk) nCT=2;
	   else nCT=1;
	   AddSPE(tphoton*fSampling,wave,nCT);
	}
      }
    }
    if(fBaselineRMS>0.0) AddLineNoise(wave);
    if(fDarkNoiseRate > 0.0) AddDarkNoise(wave);
    CreateSaturation(wave);
  }


  double SimArapucaSBND::FindMinimumTimeLite(std::map< int, int > const& photonMap){

    for (auto const& mapMember: photonMap){
 	 if(mapMember.second!=0) return (double)mapMember.first;
    }
    return 1e5;
  }

}
