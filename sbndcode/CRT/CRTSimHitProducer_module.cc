/////////////////////////////////////////////////////////////////////////////
/// Class:       CRTSimHitProducer
/// Module Type: producer
/// File:        CRTSimHitProducer_module.cc
///
/// Author:         Thomas Brooks
/// E-mail address: tbrooks@fnal.gov
///
/// Modified from CRTSimHitProducer by Thomas Warburton.
/////////////////////////////////////////////////////////////////////////////

// sbndcode includes
#include "sbndcode/CRT/CRTProducts/CRTData.hh"
#include "sbndcode/CRT/CRTProducts/CRTHit.hh"

// Framework includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Event.h" 
#include "canvas/Persistency/Common/Ptr.h" 
#include "canvas/Persistency/Common/PtrVector.h" 
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileService.h" 
#include "art/Framework/Services/Optional/TFileDirectory.h"

#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <iostream>
#include <map>
#include <iterator>
#include <algorithm>

// LArSoft
#include "lardataobj/Simulation/SimChannel.h"
#include "lardataobj/Simulation/AuxDetSimChannel.h"
#include "larcore/Geometry/Geometry.h"
#include "larcore/Geometry/AuxDetGeometry.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "larcorealg/Geometry/PlaneGeo.h"
#include "larcorealg/Geometry/WireGeo.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "lardataobj/RawData/ExternalTrigger.h"
#include "larcoreobj/SimpleTypesAndConstants/PhysicalConstants.h"

// ROOT
#include "TTree.h"
#include "TFile.h"
#include "TH1D.h"
#include "TH2D.h"
#include "TVector3.h"

namespace {
  // Local namespace for local functions

    
}

namespace sbnd {
  
  class CRTSimHitProducer : public art::EDProducer {
  public:

    explicit CRTSimHitProducer(fhicl::ParameterSet const & p);

    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    CRTSimHitProducer(CRTSimHitProducer const &) = delete;
    CRTSimHitProducer(CRTSimHitProducer &&) = delete;
    CRTSimHitProducer & operator = (CRTSimHitProducer const &) = delete; 
    CRTSimHitProducer & operator = (CRTSimHitProducer &&) = delete;

    // Required functions.
    void produce(art::Event & e) override;

    // Selected optional functions.
    void beginJob() override;

    void endJob() override;

    void reconfigure(fhicl::ParameterSet const & p);

    std::vector<double> ChannelToLimits(uint32_t channel, size_t crt_i, double x, double ex);

    std::vector<double> CrtOverlap(std::vector<double> strip1, std::vector<double> strip2, int plane);

  private:

    // Params got from fcl file.......
    art::InputTag fCrtModuleLabel;     ///< name of crt producer
    bool          fVerbose;            ///< print info

    // Positions of the CRT planes
    std::vector<double> crtPlanes = {-359.1, -357.3, 357.3, 359.1, -358.9, -357.1, 661.52, 663.32, 865.52, 867.32, -240.65, -238.85, 655.35, 657.15};
    std::vector<int> fixCoord   = {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2}; // Fixed coordinate for each plane
    std::vector<int> widthCoord = {2, 1, 2, 1, 0, 2, 2, 0, 2, 0, 1, 0, 1, 0}; // Width direction for each plane
    std::vector<int> lenCoord   = {1, 2, 1, 2, 2, 0, 0, 2, 0, 2, 0, 1, 0, 1}; // Length direction for each plane
   
    // Other variables shared between different methods.
    geo::GeometryCore const* fGeometryService;                 ///< pointer to Geometry provider
    detinfo::DetectorProperties const* fDetectorProperties;    ///< pointer to detector properties provider
    art::ServiceHandle<geo::AuxDetGeometry> fAuxDetGeoService;
    const geo::AuxDetGeometry* fAuxDetGeo;
    const geo::AuxDetGeometryCore* fAuxDetGeoCore;

  }; // class CRTSimHitProducer


  CRTSimHitProducer::CRTSimHitProducer(fhicl::ParameterSet const & p)
  // Initialize member data here, if know don't want to reconfigure on the fly
  {
    // Call appropriate produces<>() functions here.
    produces< std::vector<crt::CRTHit> >();
    
    // Get a pointer to the geometry service provider
    fGeometryService = lar::providerFrom<geo::Geometry>();
    fDetectorProperties = lar::providerFrom<detinfo::DetectorPropertiesService>(); 
    fAuxDetGeo = &(*fAuxDetGeoService);
    fAuxDetGeoCore = fAuxDetGeo->GetProviderPtr();

    reconfigure(p);

  } // CRTSimHitProducer()

  void CRTSimHitProducer::reconfigure(fhicl::ParameterSet const & p)
  {
    fCrtModuleLabel   = (p.get<art::InputTag> ("CrtModuleLabel")); 
    fVerbose          = (p.get<bool> ("Verbose"));
  }

  void CRTSimHitProducer::beginJob()
  {
    if(fVerbose){std::cout<<"----------------- CRT Hit Reco Module -------------------"<<std::endl;}
  } // beginJob()

  void CRTSimHitProducer::produce(art::Event & event)
  {

    if(fVerbose){
      std::cout<<"============================================"<<std::endl
               <<"Run = "<<event.run()<<", SubRun = "<<event.subRun()<<", Event = "<<event.id().event()<<std::endl
               <<"============================================"<<std::endl;
    }

    // Retrieve list of CRT hits
    art::Handle< std::vector<crt::CRTData>> crtListHandle;
    std::vector<art::Ptr<crt::CRTData> > crtList;
    if (event.getByLabel(fCrtModuleLabel, crtListHandle))
      art::fill_ptr_vector(crtList, crtListHandle);

    // Create anab::T0 objects and make association with recob::Track
    std::unique_ptr< std::vector<crt::CRTHit> > CRTHitcol( new std::vector<crt::CRTHit>);

    // Fill a vector of pairs of time and width direction for each CRT plane
    // The y crossing point of z planes and z crossing point of y planes would be constant
    struct CRTStrip {double t0; uint32_t channel; double x; double ex; int id1; int id2;};
    std::vector<std::vector<CRTStrip>> crtStrips;
    for(size_t plane_i = 0; plane_i < crtPlanes.size(); plane_i++){
      std::vector<CRTStrip> temp;
      crtStrips.push_back(temp);
    }

    // Loop over all the SiPM hits in 2 (should be in pairs due to trigger)
    for (size_t i = 0; i < crtList.size(); i+=2){
      // Get the time, channel, center and width
      int crtT1 = crtList[i]->T0();
      double t1 = (double)crtT1;
      t1 = t1/8.;
      uint32_t channel = crtList[i]->Channel();
      int strip = (channel >> 1) & 15;
      int module = (channel >> 5);
      std::string name = fGeometryService->AuxDet(module).TotalVolume()->GetName();
      TVector3 center = fAuxDetGeoCore->AuxDetChannelToPosition(2*strip, name);
      const geo::AuxDetSensitiveGeo stripGeo = fAuxDetGeoCore->ChannelToAuxDetSensitive(name, 2*strip);
      double width = 2*stripGeo.HalfWidth1();

      // Loop over all the planes
      for (size_t plane_i = 0; plane_i < crtPlanes.size(); plane_i++){
        // Sort the hit SiPMs by what plane they're in
        if (std::abs(center[fixCoord[plane_i]] - crtPlanes[plane_i])<0.1){

          // Get the time of hit on the second SiPM
          int crtT2 = crtList[i+1]->T0();
          double t2 = (double)crtT2;
          t2 = t2/8.;

          // Calculate the number of photoelectrons at each SiPM
          // (Hardcoded numbers from the CRT simulation)
          double npe1 = ((double)crtList[i]->ADC() - 63.6)/131.9;
          double npe2 = ((double)crtList[i+1]->ADC() - 63.6)/131.9;

          // Calculate the distance between the SiPMs
          double x = (width/2.)*atan(log(1.*npe2/npe1)) + (width/2.);
          if(widthCoord[plane_i]==1) x = (width/2.)*atan(log(1.*npe1/npe2)) + (width/2.);

          // Calculate the error
          double normx = x + 0.344677*x - 1.92045;
          double ex = 1.92380e+00+1.47186e-02*normx-5.29446e-03*normx*normx;
          double time = (t1 + t2)/2.;

          CRTStrip strip = {time, channel, x, ex, crtList[i]->TrackID(), crtList[i+1]->TrackID()};
          crtStrips[plane_i].push_back(strip);
        }
      }
    }

    // Remove duplicate strip hits
    for(size_t plane_i = 0; plane_i < crtPlanes.size(); plane_i++){

      // Sort by t0 and channel in ascending order
      std::sort(crtStrips[plane_i].begin(), crtStrips[plane_i].end(),
                [](const CRTStrip & a, const CRTStrip & b) -> bool{
                  return (a.t0 < b.t0) || 
                         ((a.t0 == b.t0) && (a.channel < b.channel));
                });

      // Remove hits with the same time and channel
      crtStrips[plane_i].erase(std::unique(crtStrips[plane_i].begin(), crtStrips[plane_i].end(),
                                           [](const CRTStrip & a, const CRTStrip & b) -> bool{
                                             return a.t0 == b.t0 && a.channel == b.channel;
                                            }), crtStrips[plane_i].end());
    }

    //Loop over number of tagger planes
    for (size_t tag_i = 0; tag_i < crtPlanes.size()/2; tag_i++){

      // Loop over the number of hit strips on even planes
      for (size_t hit_i = 0; hit_i < crtStrips[tag_i*2].size(); hit_i++){
        // Get the position (in real space) of the 4 corners of the hit, taking charge sharing into account
        std::vector<double> limits1 = ChannelToLimits(crtStrips[tag_i*2][hit_i].channel, 
                                                      tag_i*2, 
                                                      crtStrips[tag_i*2][hit_i].x, 
                                                      crtStrips[tag_i*2][hit_i].ex);

        // Loop over all the hits on the parallel (odd) plane
        for (size_t hit_j = 0; hit_j < crtStrips[tag_i*2+1].size(); hit_j++){
          // Get the limits in the two variable directions
          std::vector<double> limits2 = ChannelToLimits(crtStrips[tag_i*2+1][hit_j].channel, 
                                                        tag_i*2+1, 
                                                        crtStrips[tag_i*2+1][hit_j].x, 
                                                        crtStrips[tag_i*2+1][hit_j].ex);

          // If the time and position match then record the pair of hits
          std::vector<double> overlap = CrtOverlap(limits1, limits2, fixCoord[tag_i*2]);
          if (overlap[0] != -99999 && std::abs(crtStrips[tag_i*2][hit_i].t0 - crtStrips[tag_i*2+1][hit_j].t0)<0.1){
            // Calculate the mean and error in x, y, z
            double meanX = (overlap[0] + overlap[1])/2.;
            double meanY = (overlap[2] + overlap[3])/2.;
            double meanZ = (overlap[4] + overlap[5])/2.;
            double errX = std::abs((overlap[1] - overlap[0])/2.);
            double errY = std::abs((overlap[3] - overlap[2])/2.);
            double errZ = std::abs((overlap[5] - overlap[4])/2.);
            // Average the time
            double time = (crtStrips[tag_i*2][hit_i].t0 + crtStrips[tag_i*2+1][hit_j].t0)/2;
            
            // Create a CRT hit
            crt::CRTHit crtHit;
            crtHit.ts0_ticks = time; 
            crtHit.plane = tag_i;
            crtHit.x_pos = meanX;
            crtHit.x_err = errX;
            crtHit.y_pos = meanY; 
            crtHit.y_err = errY;
            crtHit.z_pos = meanZ;
            crtHit.z_err = errZ;
            CRTHitcol->push_back(crtHit);
          }
        }

        // If we're looking at the bottom plane need to consider non perpendicular planes
        if (tag_i == 2){
          double meanX = (limits1[0] + limits1[1])/2.;
          double meanY = (limits1[2] + limits1[3])/2.;
          double meanZ = (limits1[4] + limits1[5])/2.;
          double errX = std::abs((limits1[1] - limits1[0])/2.);
          double errY = std::abs((limits1[3] - limits1[2])/2.);
          double errZ = std::abs((limits1[5] - limits1[4])/2.);
          
          // If we're in the positions where there is only an X or Y plane
          if( !((meanZ>400 && meanX<-125) || (meanZ>400 && meanX>125) || (meanZ<0 && meanX<-125) || (meanZ<0 && meanX>124)) ){

            // If it's an X plane
            if(meanZ>400||meanZ<0){
              // Just use the single plane limits as the crt hit
              crt::CRTHit crtHit;
              crtHit.ts0_ticks = crtStrips[tag_i*2][hit_i].t0; 
              crtHit.plane = tag_i;
              crtHit.x_pos = meanX;
              crtHit.x_err = errX;
              crtHit.y_pos = meanY; 
              crtHit.y_err = errY;
              crtHit.z_pos = meanZ;
              crtHit.z_err = errZ;
              CRTHitcol->push_back(crtHit);
            }

            // If it's a Y plane
            else{
              // Recalculate the limits with different orientation
              // CRT strip plane number stays the same because they are the at the same level as the X strips
              limits1 =  ChannelToLimits(crtStrips[tag_i*2][hit_i].channel, tag_i*2+1, crtStrips[tag_i*2][hit_i].x, crtStrips[tag_i*2][hit_i].ex);
              meanX = (limits1[0] + limits1[1])/2.;
              meanY = (limits1[2] + limits1[3])/2.;
              meanZ = (limits1[4] + limits1[5])/2.;
              errX = std::abs((limits1[1] - limits1[0])/2.);
              errY = std::abs((limits1[3] - limits1[2])/2.);
              errZ = std::abs((limits1[5] - limits1[4])/2.);
              // Use the single plane limits as the crt hit
              crt::CRTHit crtHit;
              crtHit.ts0_ticks = crtStrips[tag_i*2][hit_i].t0; 
              crtHit.plane = tag_i;
              crtHit.x_pos = meanX;
              crtHit.x_err = errX;
              crtHit.y_pos = meanY; 
              crtHit.y_err = errY;
              crtHit.z_pos = meanZ;
              crtHit.z_err = errZ;
              CRTHitcol->push_back(crtHit);
            }
          }
        }
      }
    }

    event.put(std::move(CRTHitcol));
    
  } // produce()

  void CRTSimHitProducer::endJob()
  {

  }

  // Function to calculate the strip position limits in real space from channel
  std::vector<double> CRTSimHitProducer::ChannelToLimits(uint32_t channel, size_t crt_i, double x, double ex){
    // Retrieve the strip geometry
    int strip = (channel >> 1) & 15;
    int module = (channel >> 5);
    std::string name = fGeometryService->AuxDet(module).TotalVolume()->GetName();
    const geo::AuxDetSensitiveGeo stripGeo = fAuxDetGeoCore->ChannelToAuxDetSensitive(name, 2*strip);
    geo::Point_t cent = stripGeo.GetCenter();
    TVector3 center = {cent.X(), cent.Y(), cent.Z()};
    double halfWidth = stripGeo.HalfWidth1();
    double halfHeight = stripGeo.HalfHeight();

    // Use the geometry to get the limits in the two variable directions
    double varMin = center[widthCoord[crt_i]] - halfWidth + x - ex; 
    double varMax = center[widthCoord[crt_i]] - halfWidth + x + ex;
    double lenMin = center[lenCoord[crt_i]] - halfHeight;
    double lenMax = center[lenCoord[crt_i]] + halfHeight;

    // Fill the correct x,y,z limits
    std::vector<double> limits = {-99999, -99999, -99999, -99999, -99999, -99999};
    limits[2*fixCoord[crt_i]] = center[fixCoord[crt_i]];
    limits[2*fixCoord[crt_i]+1] = center[fixCoord[crt_i]];
    limits[2*widthCoord[crt_i]] = varMin;
    limits[2*widthCoord[crt_i]+1] = varMax;
    limits[2*lenCoord[crt_i]] = lenMin;
    limits[2*lenCoord[crt_i]+1] = lenMax;
    return limits;
  } // CRTSimHitProducer::ChannelToLimits

  // Function to calculate the overlap between two crt strips
  std::vector<double> CRTSimHitProducer::CrtOverlap(std::vector<double> strip1, std::vector<double> strip2, int plane){
    double minX = std::max(strip1[0], strip2[0]);
    double maxX = std::min(strip1[1], strip2[1]);
    double minY = std::max(strip1[2], strip2[2]);
    double maxY = std::min(strip1[3], strip2[3]);
    double minZ = std::max(strip1[4], strip2[4]);
    double maxZ = std::min(strip1[5], strip2[5]);
    std::vector<double> null = {-99999, -99999, -99999, -99999, -99999, -99999};

    // Check that the strips actually overlap
    if (plane == 0 && (minY>maxY || minZ>maxZ)) return null;
    if (plane == 1 && (minX>maxX || minZ>maxZ)) return null;
    if (plane == 2 && (minX>maxX || minY>maxY)) return null;
    std::vector<double> overlap = {minX, maxX, minY, maxY, minZ, maxZ};
    return overlap;
  } // CRTSimHitProducer::CRTOverlap()

  DEFINE_ART_MODULE(CRTSimHitProducer)

} // sbnd namespace

namespace {


}
