////////////////////////////////////////////////////////////////////////
// Class:       Lifetime
// Module Type: analyzer
// File:        Lifetime_module.cc
//
// Generated at Fri Dec 13 08:28:32 2019 by Dominic Barker using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////

//Art includes 
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "art_root_io/TFileService.h"

//larsoft includes
#include "lardataobj/RawData/RawDigit.h"
#include "lardataobj/RawData/raw.h"
#include "lardataobj/RecoBase/Hit.h"
#include "larcoreobj/SimpleTypesAndConstants/geo_types.h"
#include "larcore/Geometry/Geometry.h"

//C++ includes 
#include <string> 


//Root Includes
#include "TGraph.h"

class Lifetime;

class Lifetime : public art::EDAnalyzer {
public:
  explicit Lifetime(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  Lifetime(Lifetime const &) = delete;
  Lifetime(Lifetime &&) = delete;
  Lifetime & operator = (Lifetime const &) = delete;
  Lifetime & operator = (Lifetime &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;


private:

  //Service handles.
  art::ServiceHandle<geo::Geometry> geom;
  art::ServiceHandle<art::TFileService> tfs;

  std::string fRawDigitsModuleLabel;
  std::string fHitModelLabel;
  bool fUncompressWithPed; 
  float fADCMin;
  // Declare member data here.

};


Lifetime::Lifetime(fhicl::ParameterSet const & pset)
  :
  EDAnalyzer(pset),
  fRawDigitsModuleLabel(pset.get<std::string>("RawDigitsModuleLabel")),
  fHitModelLabel(pset.get<std::string>("HitModelLabel")),
  fUncompressWithPed(pset.get<bool>("UncompressWithPed")),
  fADCMin(pset.get<float>("ADCMin"))
 // More initializers here.
{}

void Lifetime::analyze(art::Event const & e){


  // Implementation of required member function here.
  art::Handle< std::vector<raw::RawDigit> > rawdigitListHandle;
  std::vector<art::Ptr<raw::RawDigit> > rawdigits;
  if (e.getByLabel(fRawDigitsModuleLabel,rawdigitListHandle))
    art::fill_ptr_vector(rawdigits, rawdigitListHandle);

  //Association between raw digits and hits.                      
  art::FindManyP<recob::Hit> fmhrd(rawdigits, e, fHitModelLabel);
  if(!fmhrd.isValid()){
    //Exceptions kill the code if this happens the code will stop
    throw cet::exception("Lifetime_module") << "The hit rawdigit association you set up is incorrect.";
    return;
  }

  //Get the first raw digit. This might no be ordered. 
  art::Ptr<raw::RawDigit> rawdigit_single = rawdigits[0];
  
  //Get the assoicated hits and add up the charge. Again there maybe no hits.
  std::vector<art::Ptr<recob::Hit> > hits_associated_to_digit = fmhrd.at(rawdigit_single.key());
  int TotalCharge = 0; 
  for(auto const& hit: hits_associated_to_digit){
    TotalCharge += hit->Integral();
  }
  std::cout << "Total charge from the first hits in the raw digit: " << TotalCharge << " with: " << hits_associated_to_digit.size() << " hits on the waveform" << std::endl;

  //Lets draw a TGraph to get a rough picture of a muon.
  //Lets use the TFileServices to do so 
  std::string EventID = "Event: " + std::to_string(e.event()) + " " +  std::to_string(e.subRun()) +  std::to_string(e.run());
  std::string Induction0Graph_name = "Induction0Graph_" + EventID;
  std::string Induction1Graph_name = "Induction1Graph_" + EventID;
  std::string CollectionGraph_name = "CollectionGraph_" + EventID;


  TGraph* Induction0Graph = tfs->makeAndRegister<TGraph>(Induction0Graph_name.c_str(),Induction0Graph_name.c_str());
  TGraph* Induction1Graph = tfs->makeAndRegister<TGraph>(Induction1Graph_name,Induction1Graph_name.c_str());
  TGraph* CollectionGraph = tfs->makeAndRegister<TGraph>(CollectionGraph_name,CollectionGraph_name.c_str());

 
  std::vector<short> rawadcs; 
  for(auto const& rawdigit: rawdigits){
    const uint32_t      channel   = rawdigit->Channel();
    const unsigned int  numticks  = rawdigit->Samples();

    rawadcs.resize(numticks);
    
    if (fUncompressWithPed){
      int pedestal = (int)rawdigit->GetPedestal();
      raw::Uncompress(rawdigit->ADCs(), rawadcs, pedestal, rawdigit->Compression());
    }
    else{
      raw::Uncompress(rawdigit->ADCs(), rawadcs, rawdigit->Compression());
    }

    //Get the wire id that corresponds to the channel 
    std::vector<geo::WireID> Wire = geom->ChannelToWire(channel);

    //We only have one wire id to the channel
    if(Wire.size() != 1){
      //Message facility warnings will not stop the code. In this case we will move to the next event.
      mf::LogWarning("Lifetime_module") << "Dom Made an assumption that there is one wire ID per channel in your detector. This is not the case and he is bailing becuase of it"  << std::endl;
      return;
    }

    //Locate the maximium point on the channel. 
    float maxADC = -9999;
    int mmaxADC_iter = -9999;
    int i = 0;
    for(auto const& rawadc: rawadcs){
      float pedestal_reduced_adc = rawadc - rawdigit->GetPedestal();
      if(pedestal_reduced_adc > maxADC){
	maxADC = pedestal_reduced_adc;
	mmaxADC_iter = i;
      }
      ++i;
    }
    
    //Only identify max points above some threshold 
    if(maxADC < fADCMin){continue;}

    //Identify which graph to fill. 
    //Maybe not the most efficient code.
    //Also could do this in wire ID map to make code more robust but I thought I'd leave that till when you start something properly.
    if(Wire[0].Plane == 0){
      Induction0Graph->SetPoint(Induction0Graph->GetN(),channel,mmaxADC_iter);
    }
    else if(Wire[0].Plane == 1){
     Induction1Graph->SetPoint(Induction0Graph->GetN(),channel,mmaxADC_iter);
    } 
    else if (Wire[0].Plane == 2){
      CollectionGraph->SetPoint(CollectionGraph->GetN(),channel,mmaxADC_iter); 
    }
  }

  //The tfile service automatically writes the graphs to the file so we are doing.


}

DEFINE_ART_MODULE(Lifetime)
