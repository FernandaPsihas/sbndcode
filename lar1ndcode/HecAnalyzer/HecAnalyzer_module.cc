////////////////////////////////////////////////////////////////////////
// Class:       HecAnalyzer
// Module Type: analyzer
// File:        HecAnalyzer_module.cc
//
// Generated at Tue May 31 14:09:53 2016 by Hector Mendez using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

//--Added all these headers bellow:
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"

// LArSoft Includes
#include "larsim/MCCheater/BackTracker.h"
#include "larsim/Simulation/ParticleList.h"
//--#include "larcore/Geometry/Geometry.h"
#include "larsim/Simulation/sim.h"
//--#include "larsim/Simulation/SimChannel.h"


#include "larcore/SimpleTypesAndConstants/geo_types.h"
#include "larcore/SimpleTypesAndConstants/RawTypes.h" // raw::ChannelID_t
#include "larcore/Geometry/Geometry.h"
#include "larcore/Geometry/TPCGeo.h"
#include "larcore/Geometry/PlaneGeo.h"
#include "larsim/Simulation/SimChannel.h"
#include "larsim/Simulation/LArG4Parameters.h"
#include "lardata/RawData/RawDigit.h"
#include "lardata/RecoBase/Wire.h"
#include "lardata/RecoBase/Hit.h"
#include "lardata/RecoBaseArt/HitCreator.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/Utilities/StatCollector.h"



// C++ Includes
#include <map>
#include <vector>
#include <algorithm>
#include <iostream>
#include <string>
#include <cmath>

// ROOT includes
#include "TH1.h"
#include "TH2.h"
#include "TTree.h"
#include "TLorentzVector.h"
#include "TVector3.h"
#include "TProfile.h"


namespace lar1nd {
  class HecAnalyzer;
}
namespace sim{                    //--Hec: added on Jul 16, 2015
  class ParticleList;
}
class lar1nd::HecAnalyzer : public art::EDAnalyzer {
public:
  explicit HecAnalyzer(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  HecAnalyzer(HecAnalyzer const &) = delete;
  HecAnalyzer(HecAnalyzer &&) = delete;
  HecAnalyzer & operator = (HecAnalyzer const &) = delete;
  HecAnalyzer & operator = (HecAnalyzer &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;
  void reconfigure(fhicl::ParameterSet const & p) override;

private:
  // Declare member data here.
    TTree *Hec0Tree;
    TTree *Hec1Tree;
    //--n-Tuple variables
    int runNumber, evtNumber, subrunNumber;
    int NsimCh;
    double totalCharge, totalEnergy;
    double numIDEs, scCharge, scEnergy, scChargeIv, scEnergyIv;
    int viewSC, nChOn, viewTDC, ideOn;
    double channelN;
    double chX, chY, chZ, ratioQoE;
    
    TH1D *fnumChannels;           //< The number of channels recieving charge per event
    TProfile *fnumIDEs;           //< Number of drift electrons per channel.
    TH1D *fEventCharge;           //< Charge collected per event
    TH1D *fEventEnergy;           //< Energy collected per event
    TProfile *fChannelCharge;     //< Charge per channel.
    TProfile *fChannelEnergy;     //< Energy per channel.
    TH1D *chargex, *chargey, *chargez;
    TH2D *chargezy[4];
    TH1D *Qposx[3];
    TH1D *ChannelOn, *ViewOn, *idevecOn, *fchanOn;
    TProfile *fratioQoE[3], *ChargeX[3], *EnergyX[3];
    
  // Declare member data here.
  // The parameters from the .fcl file.
  std::string fG4ModuleLabel;
};


lar1nd::HecAnalyzer::HecAnalyzer(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{
  std::cout<<std::endl;
  std::cout<<"--Hec: Calling lar1nd::HecAnalyzer::HecAnalyzer"<<std::endl;
  std::cout<<std::endl;
 
  // Read in the parameters from the .fcl file.
  this->reconfigure(p);
}

void lar1nd::HecAnalyzer::analyze(art::Event const & e)
{
  // Implementation of required member function here.
  runNumber    = e.run();
  evtNumber    = e.event();
  subrunNumber = e.subRun(); 
  std::cout<<std::endl;
  std::cout<<"--Hec: Calling lar1nd::HecAnalyzer::analyze:  Run="
           <<runNumber<<" Sub-Run="<<subrunNumber<<" Evt="<<evtNumber
  <<std::endl;
  std::cout<<std::endl;
  
 ////Andrzej copying things
    art::ServiceHandle<geo::Geometry> geom;
    unsigned int fNTPC=geom->NTPC();
    
    //get the list of particles from this event
    art::ServiceHandle<cheat::BackTracker> bt;
    const sim::ParticleList& plist = bt->ParticleList(); //this is coming from larsim/LArG4/LArG4Ana_module.cc

    // loop over all sim::SimChannels in the event and make sure there are no
    // sim::IDEs with trackID values that are not in the sim::ParticleList
    std::vector<const sim::SimChannel*> sccol;
    e.getView(fG4ModuleLabel, sccol);
    NsimCh = sccol.size();
    std::cout<<"--Hec: fNTPC:"<<fNTPC<<" Number of Simulated Channels. SimChannels: sccol.size():" <<NsimCh<< std::endl;

    totalCharge=0.0;
    totalEnergy=0.0;
    fnumChannels->Fill(NsimCh);
    
    for(size_t sc = 0; sc < sccol.size(); ++sc){  //--Looping on Simulated Channels
      numIDEs=0.;
      scCharge=0.;
      scEnergy=0.;
      scChargeIv=0.;
      scEnergyIv=0.;
       
      //raw::ChannelID_t channel = sc->Channel(); //--Jun 13, 2016
      //geo::View_t view0 = geom->View(channel);   // we need to distinguish the U and V planes
      geo::View_t view0 = geom->View(sc);   // we need to distinguish the U and V planes
      viewSC = view0;
           
      //--Look TDC (time to digital converter)signals
      const std::map<unsigned short, std::vector<sim::IDE> >& tdcidemap = sccol[sc]->TDCIDEMap();
      nChOn = tdcidemap.size();
      std::cout<<" --Hec: "<<sc<<" tdcidemap.end():"<<nChOn<<std::endl;
      fchanOn->Fill(nChOn);
      
      for(auto mapitr = tdcidemap.begin(); mapitr != tdcidemap.end(); mapitr++){  //--Loop on TDC
	const std::vector<sim::IDE> idevec = (*mapitr).second;
	numIDEs += idevec.size();
	
	channelN = (*mapitr).first;
        geo::View_t view = geom->View(channelN);   // we need to distiguish the U and V planes
	viewTDC = view;
	ideOn = idevec.size();
	
        ChannelOn -> Fill(channelN);      //--Histograms
        ViewOn    -> Fill(viewTDC);       //--Histograms
	idevecOn  -> Fill(ideOn);         //--Histograms
	
	bool cut = channelN > 1900;
	cut = true;
	//cut = view>0;
	if( cut )
	std::cout<<"  --Hec: [sc,view0]: ["<<sc<<","<<view0<<"] numIDEs:"<<numIDEs<<"+"<<ideOn<<" "
	      <<" [(*mapitr).first,view]: ["<<channelN<<","<<view<<"]"
	      <<view0<<" "<<view<<std::endl;
	
	for(size_t iv = 0; iv < idevec.size(); ++iv){
	  if(plist.find( idevec[iv].trackID ) == plist.end()
	     && idevec[iv].trackID != sim::NoParticleId) 
	  mf::LogWarning("LArG4Ana") << idevec[iv].trackID << " --Hec: is not in particle list"; 
	  totalCharge += idevec[iv].numElectrons;
	  scCharge    += idevec[iv].numElectrons; //The number of ionization electrons associated with this channel for the specified TDC.
	  scChargeIv   = idevec[iv].numElectrons; 
	  totalEnergy += idevec[iv].energy;
	  scEnergy    += idevec[iv].energy;       //Total energy deposit associated with this channel for the specified TDC. 
          scEnergyIv   = idevec[iv].energy;

          //for (const auto& ide : ideVec) {
	  //totalElectrons += ide.numElectrons;
	  if( cut )
          std::cout<<"v0: "<<viewSC<<"   --Hec: "<<iv<<" v:"<<view<<" z = "<<idevec[iv].z
	                                                          <<" x = "<<idevec[iv].x
								  <<" y = "<<idevec[iv].y<<std::endl;
							       //<<" diff = "<<idevec[iv].x - idevec[iv].y<<std::endl;
          //}
          
	  chX = idevec[iv].x;
	  chY = idevec[iv].y;
	  chZ = idevec[iv].z;
	  
          chargex->Fill(chX);
          chargey->Fill(chY);
          chargez->Fill(chZ);
	  
	  //bool cut = view == 1 && idevec.size() < 5;
          //if(cut){
          if(channelN == 1332) chargezy[0]->Fill(chZ, chY);
          if(channelN == 1339) chargezy[1]->Fill(chZ, chY);
          if(channelN == 2023) chargezy[2]->Fill(chZ, chY);
          if(channelN == 2386) chargezy[3]->Fill(chZ, chY);

          
	//for(size_t i=0; i<=2; i++)
        //   if( i==view )Qposx[view]->Fill(idevec[iv].x);
	  Qposx[view]->Fill(chX);
	  
	  ratioQoE = idevec[iv].numElectrons/idevec[iv].energy;
	  fratioQoE[view]->Fill(idevec[iv].x,ratioQoE);
	  ChargeX[view]  ->Fill(idevec[iv].x,idevec[iv].numElectrons);
	  EnergyX[view]  ->Fill(idevec[iv].x,idevec[iv].energy);
	  
	  Hec0Tree->Fill();
	  
	}  //--end for(size_t iv = 0; iv < idevec.size(); ++iv){
      }    //--end for(auto mapitr = tdcidemap.begin(); mapitr != tdcidemap.end(); mapitr++){
      std::cout<<"--Hec: sc:"<<sc<<" numIDEs:"<<numIDEs<<std::endl;
      fnumIDEs->Fill(sc,numIDEs);
      fChannelCharge->Fill(sc,scCharge);
      fChannelEnergy->Fill(sc,scEnergy);
    }  //--end for(size_t sc = 0; sc < sccol.size(); ++sc){
   fEventCharge->Fill(totalCharge);
   fEventEnergy->Fill(totalEnergy);
   std::cout << "--Hec: totalCharge:    " << totalCharge << std::endl;
   std::cout << "--Hec: totalEnergy:    " << totalEnergy << std::endl;

////end Andrzej copying things 
}

void lar1nd::HecAnalyzer::beginJob()
{  
  art::ServiceHandle<art::TFileService> tfs;
  
  // Implementation of optional member function here.
  std::cout<<std::endl;
  std::cout<<"--Hec: Calling lar1nd::HecAnalyzer::beginJob()"<<std::endl;
  std::cout<<std::endl;
  

  Hec0Tree = tfs->make<TTree>("HecGeo0","CHK Geo Tree");
  Hec0Tree->Branch("run",       &runNumber,   "run/I");
  Hec0Tree->Branch("subrun",    &subrunNumber,"subrun/I");
  Hec0Tree->Branch("event",     &evtNumber,   "event/I");
  Hec0Tree->Branch("NsimCh",    &NsimCh,      "NsimCh/I");
  Hec0Tree->Branch("totCharge", &totalCharge, "totalCharge/D");
  Hec0Tree->Branch("totEnergy", &totalEnergy, "totalEnergy/D");
  Hec0Tree->Branch("numIDE",    &numIDEs,     "numIDEs/D");
  Hec0Tree->Branch("scChar",    &scCharge,    "scCharge/D");
  Hec0Tree->Branch("scEner",    &scEnergy,    "scEnergy/D");
  Hec0Tree->Branch("scCharIv",  &scChargeIv,  "scChargeIv/D"); 
  Hec0Tree->Branch("scEnerIv",  &scEnergyIv,  "scEnergyIv/D");
  Hec0Tree->Branch("viewSC",    &viewSC,      "viewSC/I");
  Hec0Tree->Branch("nChOn",     &nChOn,       "nChOn/I");
  Hec0Tree->Branch("viewTDC",   &viewTDC,     "viewTDC/I");
  Hec0Tree->Branch("ideOn",     &ideOn,       "ideOn/I");
  Hec0Tree->Branch("channelN",  &channelN,    "channelN/D");
  Hec0Tree->Branch("chX",       &chX,         "chX/D");
  Hec0Tree->Branch("chY",       &chY,         "chY/D");
  Hec0Tree->Branch("chZ",       &chZ,         "chZ/D");
  Hec0Tree->Branch("ratioQoE",  &ratioQoE,    "ratioQoE/D");
    
  art::ServiceHandle<geo::Geometry> geom;
  
  double Nch = geom->Nchannels();
  std::cout << "--Hec: Nchannels:" << Nch << std::endl;

    // Some histograms relating to drift electrons, active detector
    // channels and charge/energy on channels
    fnumChannels   = tfs->make<TH1D>("fnumChannels","Active channels;Active channels;# events",Nch, 0, Nch); 
    fnumIDEs       = tfs->make<TProfile>("fnumIDEs","Drift Electrons per channel;Channel;Drift electrons",Nch+1, 0,Nch,0, 1e4); 
    fEventCharge   = tfs->make<TH1D>("fEventCharge","Charge in event;Total charge per event;# events",100, 0, 2.5e8); 
    fEventEnergy   = tfs->make<TH1D>("fEventEnergy","Energy in event;Total energy per event;# events",100, 0, 1e4); 
    fChannelCharge = tfs->make<TProfile>("fChannelCharge","Charge on channel;Channel;Total charge per channel",Nch+1,0,Nch,0,1e5);
    fChannelEnergy = tfs->make<TProfile>("fChannelEnergy","Energy on channel;Channel;Total energy per channel",Nch+1,0,Nch,0,1e3); 

    chargex  = tfs->make<TH1D>("chargex", "Charge x position", 1000, -500, 500);
    chargey  = tfs->make<TH1D>("chargey", "Charge y position", 1000, -500, 500); 
    chargez  = tfs->make<TH1D>("chargez", "Charge z position", 1000, 0, 1000);
    
    chargezy[0] = tfs->make<TH2D>("chargexy[0]", "Charge z vs y position_channel 1332", 1700, 0, 510, 1500, -225, 225); 
    chargezy[1] = tfs->make<TH2D>("chargexy[1]", "Charge z vs y position_channel 1339", 1700, 0, 510, 1500, -225, 225); 
    chargezy[2] = tfs->make<TH2D>("chargexy[2]", "Charge z vs y position_channel 2500", 1700, 0, 510, 1500, -225, 225); 
    chargezy[3] = tfs->make<TH2D>("chargexy[3]", "Charge z vs y position_channel 2150", 1700, 0, 510, 1500, -225, 225); 
    
    Qposx[0] = tfs->make<TH1D>("qposx0", "Charge X position 0", 10000, -250, 250);
    Qposx[1] = tfs->make<TH1D>("qposx1", "Charge X position 1", 10000, -250, 250);
    Qposx[2] = tfs->make<TH1D>("qposx2", "Charge X position 2", 10000, -250, 250);

    fratioQoE[0] = tfs->make<TProfile>("fratioQoE0", "Ratio of charge over energy as a function of x0",400, -200, 200,0, 2e4);
    fratioQoE[1] = tfs->make<TProfile>("fratioQoE1", "Ratio of charge over energy as a function of x1",400, -200, 200,0, 2e4);
    fratioQoE[2] = tfs->make<TProfile>("fratioQoE2", "Ratio of charge over energy as a function of x2",400, -200, 200,0, 2e4);
    
    ChargeX[0] = tfs->make<TProfile>("ChargeX0", "Charge as a function of x0",400, -200, 200,0, 2e4);
    ChargeX[1] = tfs->make<TProfile>("ChargeX1", "Charge as a function of x1",400, -200, 200,0, 2e4);
    ChargeX[2] = tfs->make<TProfile>("ChargeX2", "Charge as a function of x2",400, -200, 200,0, 2e4);
    
    EnergyX[0] = tfs->make<TProfile>("EnergyX0", "Charge as a function of x0",400, -200, 200,0, 2e4);
    EnergyX[1] = tfs->make<TProfile>("EnergyX1", "Charge as a function of x1",400, -200, 200,0, 2e4);
    EnergyX[2] = tfs->make<TProfile>("EnergyX2", "Charge as a function of x2",400, -200, 200,0, 2e4);
    
    ChannelOn = tfs->make<TH1D>("ChannelOn", "Channel On", Nch, 0, Nch);
    ViewOn    = tfs->make<TH1D>("ViewOn", "View On", 3, 0, 3);
    fchanOn   = tfs->make<TH1D>("fchanOn", "Number of channels on per sc", 100, 0, 100);
    idevecOn  = tfs->make<TH1D>("idevecOn", "Number of drift electrons per channel", 20, 0, 20);
}

void lar1nd::HecAnalyzer::reconfigure(fhicl::ParameterSet const & p)
{
  // Implementation of optional member function here.
  std::cout<<std::endl;
  std::cout<<"--Hec: Calling lar1nd::HecAnalyzer::reconfigure"<<std::endl;
  std::cout<<std::endl;  
  
  fG4ModuleLabel        = p.get< std::string >("LArG4ModuleLabel");
}

DEFINE_ART_MODULE(lar1nd::HecAnalyzer)
