////////////////////////////////////////////////////////////////////////
// Class:       LarAnalyzerEg
// Module Type: analyzer
// File:        LarAnalyzerEg_module.cc
//
// Generated at Wed Oct 21 10:58:00 2015 by Jonathan Asaadi using artmod
// from cetpkgsupport v1_08_07.
////////////////////////////////////////////////////////////////////////


// ##########################
// ### Framework includes ###
// ##########################
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h" 
#include "art/Framework/Principal/Event.h" 
#include "fhiclcpp/ParameterSet.h" 
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Principal/Handle.h" 
#include "art/Persistency/Common/Ptr.h" 
#include "art/Persistency/Common/PtrVector.h" 
#include "art/Framework/Services/Registry/ServiceHandle.h" 
#include "art/Framework/Services/Optional/TFileService.h" 
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "art/Framework/Core/FindOneP.h" 
#include "messagefacility/MessageLogger/MessageLogger.h" 
#include "cetlib/maybe_ref.h"

// ########################
// ### LArSoft includes ###
// ########################
#include "SimpleTypesAndConstants/geo_types.h"
#include "SimpleTypesAndConstants/RawTypes.h" // raw::ChannelID_t
#include "Geometry/Geometry.h"
#include "Geometry/CryostatGeo.h"
#include "Geometry/TPCGeo.h"
#include "Geometry/PlaneGeo.h"
#include "Geometry/WireGeo.h"
#include "RecoBase/Wire.h"
#include "RecoBase/Hit.h"
#include "RecoBase/Cluster.h"
#include "RecoBase/Track.h"
#include "RecoBase/Vertex.h"
#include "RecoBase/SpacePoint.h"
#include "Utilities/LArProperties.h"
#include "Utilities/DetectorProperties.h"
#include "Utilities/AssociationUtil.h"
#include "RawData/ExternalTrigger.h"
#include "RawData/RawDigit.h"
#include "RawData/raw.h"
#include "MCCheater/BackTracker.h"
#include "Simulation/SimChannel.h"
#include "SimulationBase/MCTruth.h"
#include "Filters/ChannelFilter.h"
#include "AnalysisBase/Calorimetry.h"
#include "AnalysisBase/ParticleID.h"
#include "MCBase/MCShower.h"
#include "MCBase/MCStep.h"


// #####################
// ### ROOT includes ###
// #####################
#include "TComplex.h"
#include "TFile.h"
#include "TH2D.h"
#include "TF1.h"
#include "TTree.h"
#include "TTimeStamp.h"


const int kMaxPrimaries  = 20000;  //maximum number of primary particles
const int kMaxMCShower   = 1000; // maximum number of MCShower Object

class LarAnalyzerEg;

class LarAnalyzerEg : public art::EDAnalyzer {
public:
  explicit LarAnalyzerEg(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  LarAnalyzerEg(LarAnalyzerEg const &) = delete;
  LarAnalyzerEg(LarAnalyzerEg &&) = delete;
  LarAnalyzerEg & operator = (LarAnalyzerEg const &) = delete;
  LarAnalyzerEg & operator = (LarAnalyzerEg &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;

  void endJob() override;

  void reconfigure(fhicl::ParameterSet const & p) override;


private:

  // === Function used to reset all the variables  ===
   void ResetVars();
  
   // === Storing information into TTree ====
   TTree* fTree;
   
   //=== Storing Run Information ===
   int run;			//<---Run Number
   int subrun;			//<---SubRun Number
   int event;			//<---Event Number
   double evttime;		//<---Event Time Stamp
   double efield[3];		//<---Electric Field 
   int t0;
   int trigtime[16];		//<---Trigger time
   
   // === Storing Geant4 MC Truth Information ===
   int no_primaries;				//<---Number of primary Geant4 particles in the event
   int geant_list_size;				//<---Number of Geant4 particles tracked
   int pdg[kMaxPrimaries];			//<---PDG Code number of this particle
   double Eng[kMaxPrimaries];			//<---Energy of the particle
   double Px[kMaxPrimaries];			//<---Px momentum of the particle
   double Py[kMaxPrimaries];			//<---Py momentum of the particle
   double Pz[kMaxPrimaries];			//<---Pz momentum of the particle
   double StartPointx[kMaxPrimaries];		//<---X position that this Geant4 particle started at
   double StartPointy[kMaxPrimaries];		//<---Y position that this Geant4 particle started at
   double StartPointz[kMaxPrimaries];		//<---Z position that this Geant4 particle started at
   double EndPointx[kMaxPrimaries];		//<---X position that this Geant4 particle ended at
   double EndPointy[kMaxPrimaries];		//<---Y position that this Geant4 particle ended at
   double EndPointz[kMaxPrimaries];		//<---Z position that this Geant4 particle ended at
   int NumberDaughters[kMaxPrimaries];		//<---Number of Daughters this particle has
   int TrackId[kMaxPrimaries];			//<---Geant4 TrackID number
   int Mother[kMaxPrimaries];			//<---TrackID of the mother of this particle
   int process_primary[kMaxPrimaries];		//<---Is this particle primary (primary = 1, non-primary = 1)
   
   
   // ==== Storing MCShower MCTruth Information ===
   
   int     no_mcshowers;                         	//number of MC Showers in this event.
   int       mcshwr_origin[kMaxMCShower];            	//MC Shower origin information. 
   int       mcshwr_pdg[kMaxMCShower];            	//MC Shower particle PDG code.   
   int       mcshwr_TrackId[kMaxMCShower];        	//MC Shower particle G4 track ID.
   double     mcshwr_startX[kMaxMCShower];            	//MC Shower particle G4 startX 
   double     mcshwr_startY[kMaxMCShower];          	//MC Shower particle G4 startY 
   double     mcshwr_startZ[kMaxMCShower];          	//MC Shower particle G4 startZ
   double     mcshwr_endX[kMaxMCShower];            	//MC Shower particle G4 endX 
   double     mcshwr_endY[kMaxMCShower];            	//MC Shower particle G4 endY 
   double     mcshwr_endZ[kMaxMCShower];            	//MC Shower particle G4 endZ
   double    mcshwr_CombEngX[kMaxMCShower];            	//MC Shower Combined energy deposition information, Start Point X Position. 
   double    mcshwr_CombEngY[kMaxMCShower];            	//MC Shower Combined energy deposition information, Start Point Y Position.
   double    mcshwr_CombEngZ[kMaxMCShower];            	//MC Shower Combined energy deposition information, Start Point Z Position.
   double     mcshwr_CombEngPx[kMaxMCShower];           //MC Shower Combined energy deposition information, Momentum X direction.
   double     mcshwr_CombEngPy[kMaxMCShower];           //MC Shower Combined energy deposition information, Momentum X direction.
   double     mcshwr_CombEngPz[kMaxMCShower];           //MC Shower Combined energy deposition information, Momentum X direction.
   double     mcshwr_CombEngE[kMaxMCShower];            //MC Shower Combined energy deposition information, Energy
   double     mcshwr_dEdx[kMaxMCShower];           	//MC Shower dEdx, MeV/cm
   double     mcshwr_StartDirX[kMaxMCShower];      	//MC Shower Direction of begining of shower, X direction 
   double     mcshwr_StartDirY[kMaxMCShower];      	//MC Shower Direction of begining of shower, Y direction 
   double     mcshwr_StartDirZ[kMaxMCShower];      	//MC Shower Direction of begining of shower, Z direction 
   int       mcshwr_isEngDeposited[kMaxMCShower];  	//tells whether if this shower deposited energy in the detector or not.
   							//yes = 1; no =0;
   //MC Shower mother information
   int       mcshwr_Motherpdg[kMaxMCShower];       	//MC Shower's mother PDG code.
   int       mcshwr_MotherTrkId[kMaxMCShower];     	//MC Shower's mother G4 track ID.
   double     mcshwr_MotherstartX[kMaxMCShower];    	//MC Shower's mother  G4 startX .
   double     mcshwr_MotherstartY[kMaxMCShower];    	//MC Shower's mother  G4 startY .
   double     mcshwr_MotherstartZ[kMaxMCShower];    	//MC Shower's mother  G4 startZ .
   double     mcshwr_MotherendX[kMaxMCShower];          //MC Shower's mother  G4 endX   .
   double     mcshwr_MotherendY[kMaxMCShower];          //MC Shower's mother  G4 endY   .
   double     mcshwr_MotherendZ[kMaxMCShower];          //MC Shower's mother  G4 endZ   .
   
   //MC Shower ancestor information
   int       mcshwr_Ancestorpdg[kMaxMCShower];       	//MC Shower's ancestor PDG code.
   int       mcshwr_AncestorTrkId[kMaxMCShower];     	//MC Shower's ancestor G4 track ID.
   double     mcshwr_AncestorstartX[kMaxMCShower];   	//MC Shower's ancestor  G4 startX
   double     mcshwr_AncestorstartY[kMaxMCShower];   	//MC Shower's ancestor  G4 startY
   double     mcshwr_AncestorstartZ[kMaxMCShower];   	//MC Shower's ancestor  G4 startZ
   double     mcshwr_AncestorendX[kMaxMCShower];     	//MC Shower's ancestor  G4 endX 
   double     mcshwr_AncestorendY[kMaxMCShower];     	//MC Shower's ancestor  G4 endY
   double     mcshwr_AncestorendZ[kMaxMCShower];      	//MC Shower's ancestor  G4 endZ    
   
   
   
   std::string fG4ModuleLabel;
   std::string fMCShowerModuleLabel;	// Producer name that makes MCShower Object
};


LarAnalyzerEg::LarAnalyzerEg(fhicl::ParameterSet const & p) : EDAnalyzer(p)  // ,
 // More initializers here.
{
 this->reconfigure(p);
}

void LarAnalyzerEg::analyze(art::Event const & evt)
{
   // #############################################
   // ### Reset variables before we get started ###
   // #############################################
   ResetVars();
   
   // #######################################
   // ### Get potentially useful services ###
   // #######################################
   // === Geometry Service ===
   art::ServiceHandle<geo::Geometry> geom;
   // === Liquid Argon Properties Services ===
   art::ServiceHandle<util::LArProperties> larprop;
   // === Detector properties service ===
   art::ServiceHandle<util::DetectorProperties> detprop;
   // === BackTracker service ===
   art::ServiceHandle<cheat::BackTracker> bt;
   const sim::ParticleList& plist = bt->ParticleList();
   
   
   // === Run Number ===
   run = evt.run();
   // === Sub-Run Number ===
   subrun = evt.subRun();
   // === Event Number ===
   event = evt.id().event();
   
   std::cout<<std::endl;
   std::cout<<"========================================="<<std::endl;
   std::cout<<"Run = "<<run<<", SubRun = "<<subrun<<", Evt = "<<event<<std::endl;
   std::cout<<"========================================="<<std::endl;
   std::cout<<std::endl;
   
   // === Event Time ===
   art::Timestamp ts = evt.time();
   TTimeStamp tts(ts.timeHigh(), ts.timeLow());
   evttime = tts.AsDouble();
   
   // === Electric Field ===
   //efield[0] = larprop->Efield(0);
   //efield[1] = larprop->Efield(1);
   //efield[2] = larprop->Efield(2);
   
   // === Trigger Offset ====
   //t0 = detprop->TriggerOffset();
   
   // ###################################################################
   // ### Setting a boolian to only output MC info if this is MC-info ###
   // ###################################################################
   bool isdata = false;
   if (evt.isRealData())
   	{isdata = true;}
	
   else isdata = false;
   
   
   // ----------------------------------------------------------------------------------------------------------------------------
   // ----------------------------------------------------------------------------------------------------------------------------
   //							FILLING THE MCTruth Geant4 INFORMATION
   // ----------------------------------------------------------------------------------------------------------------------------
   // ----------------------------------------------------------------------------------------------------------------------------

   if(!isdata)
      {
      // ######################################
      // ### Making a vector of MCParticles ###
      // ######################################   
      std::vector<const simb::MCParticle* > geant_part;
      
      // ### Looping over all the Geant4 particles from the BackTracker ###
      for(size_t p = 0; p < plist.size(); ++p) 
         {
	 // ### Filling the vector with MC Particles ###
	 geant_part.push_back(plist.Particle(p)); 
	 }
	
      //std::cout<<"No of geant part= "<<geant_part.size()<<std::endl;
      
      // ### Setting a string for primary ###
      std::string pri("primary");
      
      int primary=0;
      int geant_particle=0;
      
      // ############################################################
      // ### Determine the number of primary particles from geant ###
      // ############################################################
      for( unsigned int i = 0; i < geant_part.size(); ++i )
         {
	 geant_particle++;
	 // ### Counting the number of primary particles ###
	 if(geant_part[i]->Process()==pri)
	    { primary++;}
	 }//<---End i loop
	 
	
       // ### Saving the number of primary particles ###
       no_primaries=primary;
       // ### Saving the number of Geant4 particles ###
       geant_list_size=geant_particle;
       
       // ### Looping over all the Geant4 particles ###
       for( unsigned int i = 0; i < geant_part.size(); ++i )
          {
	  //std::cout<<"pdg= "<<geant_part[i]->PdgCode()<<" Process= "<<geant_part[i]->Process()<<" trackId= "<<geant_part[i]->TrackId()<<" E= "<<geant_part[i]->E()<<" P= "<<geant_part[i]->P()<<" "<<sqrt(geant_part[i]->Px()*geant_part[i]->Px() + geant_part[i]->Py()*geant_part[i]->Py()+ geant_part[i]->Pz()*geant_part[i]->Pz())<<" Mother= "<<geant_part[i]->Mother()<<" Vertex= ("<<geant_part[i]->Vx()<<","<<geant_part[i]->Vy()<<","<<geant_part[i]->Vz()<<" ) end=("<<geant_part[i]->EndPosition()[0]<<","<<geant_part[i]->EndPosition()[1]<<","<<geant_part[i]->EndPosition()[2]<<")"<<std::endl;
   
          // ### If this particle is primary, set = 1 ###
	  if(geant_part[i]->Process()==pri)
	     {process_primary[i]=1;}
          // ### If this particle is not-primary, set = 0 ###
	  else
	     {process_primary[i]=0;}
   
          // ### Saving the particles mother TrackID ###
	  Mother[i]=geant_part[i]->Mother();
	  // ### Saving the particles TrackID ###
	  TrackId[i]=geant_part[i]->TrackId();
	  // ### Saving the PDG Code ###
	  pdg[i]=geant_part[i]->PdgCode();
	  // ### Saving the particles Energy ###
	  Eng[i]=geant_part[i]->E();
	  
	  // ### Saving the Px, Py, Pz info ###
	  Px[i]=geant_part[i]->Px();
	  Py[i]=geant_part[i]->Py();
	  Pz[i]=geant_part[i]->Pz();
	  
	  // ### Saving the Start and End Point for this particle ###
	  StartPointx[i]=geant_part[i]->Vx();
	  StartPointy[i]=geant_part[i]->Vy();
	  StartPointz[i]=geant_part[i]->Vz();
	  EndPointx[i]=geant_part[i]->EndPosition()[0];
	  EndPointy[i]=geant_part[i]->EndPosition()[1];
	  EndPointz[i]=geant_part[i]->EndPosition()[2];
	  
	  // ### Saving the number of Daughters for this particle ###
	  NumberDaughters[i]=geant_part[i]->NumberDaughters();
	  
	  //std::cout<<"length= "<<sqrt((EndPointx[i]-StartPointx[i])*(EndPointx[i]-StartPointx[i]) + (EndPointy[i]-StartPointy[i])*(EndPointy[i]-StartPointy[i])+ (EndPointz[i]-StartPointz[i])*(EndPointz[i]-StartPointz[i]))<<std::endl;
          } //geant particles
      
      
      art::Handle< std::vector<sim::MCShower> > mcshowerh;
      evt.getByLabel(fMCShowerModuleLabel, mcshowerh);
      
      // #######################################################
      // ### Check to make sure the MCShower Handle is valid ###
      // #######################################################
      if (mcshowerh.isValid())
         {
	 
	 //std::cout<<mcshowerh->size()<<std::endl;
	 no_mcshowers = mcshowerh->size();
	 size_t shwr = 0;
	 // ############################################################
	 // ### Looping over all MC Showers (using uBooNEAna method) ###
	 // ############################################################
         for(std::vector<sim::MCShower>::const_iterator imcshwr = mcshowerh->begin(); imcshwr != mcshowerh->end(); ++imcshwr)
	    {
	    
	    const sim::MCShower& mcshwr = *imcshwr;
	    
            mcshwr_origin[shwr]          = mcshwr.Origin();
	    mcshwr_pdg[shwr]              = mcshwr.PdgCode();
	    mcshwr_TrackId[shwr]              = mcshwr.TrackID();
	    mcshwr_startX[shwr]          = mcshwr.Start().X();
	    mcshwr_startY[shwr]          = mcshwr.Start().Y();
	    mcshwr_startZ[shwr]          = mcshwr.Start().Z();
	    mcshwr_endX[shwr]            = mcshwr.End().X();
	    mcshwr_endY[shwr]            = mcshwr.End().Y(); 
	    mcshwr_endZ[shwr]            = mcshwr.End().Z();
	    
	    // ### Recording Energy inside the detector ###
	    if (mcshwr.DetProfile().E()!= 0)
	       {
	       mcshwr_isEngDeposited[shwr] = 1;
	       mcshwr_CombEngX[shwr]        = mcshwr.DetProfile().X(); 
	       mcshwr_CombEngY[shwr]        = mcshwr.DetProfile().Y();
	       mcshwr_CombEngZ[shwr]        = mcshwr.DetProfile().Z();
	       mcshwr_CombEngPx[shwr]       = mcshwr.DetProfile().Px();
	       mcshwr_CombEngPy[shwr]       = mcshwr.DetProfile().Py();
	       mcshwr_CombEngPz[shwr]       = mcshwr.DetProfile().Pz(); 
	       mcshwr_CombEngE[shwr]        = mcshwr.DetProfile().E();
	       mcshwr_dEdx[shwr]            = mcshwr.dEdx();
	       mcshwr_StartDirX[shwr]       = mcshwr.StartDir().X();
	       mcshwr_StartDirY[shwr]       = mcshwr.StartDir().Y();
	       mcshwr_StartDirZ[shwr]       = mcshwr.StartDir().Z();
	       }//<---End recording info inside the detector
	    else
	       {mcshwr_isEngDeposited[shwr] = 0;}
	    
	    mcshwr_Motherpdg[shwr]       = mcshwr.MotherPdgCode();
	    mcshwr_MotherTrkId[shwr]     = mcshwr.MotherTrackID();
	    mcshwr_MotherstartX[shwr]    = mcshwr.MotherStart().X();
	    mcshwr_MotherstartY[shwr]    = mcshwr.MotherStart().Y();
	    mcshwr_MotherstartZ[shwr]    = mcshwr.MotherStart().Z();
	    mcshwr_MotherendX[shwr]      = mcshwr.MotherEnd().X();
	    mcshwr_MotherendY[shwr]      = mcshwr.MotherEnd().Y();
	    mcshwr_MotherendZ[shwr]      = mcshwr.MotherEnd().Z();
	    mcshwr_Ancestorpdg[shwr]     = mcshwr.AncestorPdgCode();
	    mcshwr_AncestorTrkId[shwr]   = mcshwr.AncestorTrackID();
	    mcshwr_AncestorstartX[shwr]  = mcshwr.AncestorStart().X();
	    mcshwr_AncestorstartY[shwr]  = mcshwr.AncestorStart().Y();
	    mcshwr_AncestorstartZ[shwr]  = mcshwr.AncestorStart().Z();
	    mcshwr_AncestorendX[shwr]    = mcshwr.AncestorEnd().X();
	    mcshwr_AncestorendY[shwr]    = mcshwr.AncestorEnd().Y();
	    mcshwr_AncestorendZ[shwr]    = mcshwr.AncestorEnd().Z();

      
            shwr++;
            }//<---End imcshwr iterator loop
	    
	    
         }//<---Only going in if the handle is valid
	 
	  
      }//<---End checking if this is data 
 
 fTree->Fill();
 
   
}

void LarAnalyzerEg::beginJob()
{
 
   art::ServiceHandle<art::TFileService> tfs;
   fTree = tfs->make<TTree>("anatree","analysis tree"); 
   fTree->Branch("run",&run,"run/I");
   fTree->Branch("subrun",&subrun,"subrun/I");
   fTree->Branch("event",&event,"event/I");
   fTree->Branch("evttime",&evttime,"evttime/D");
   fTree->Branch("efield",efield,"efield[3]/D");
   fTree->Branch("t0",&t0,"t0/I");
   fTree->Branch("trigtime",trigtime,"trigtime[16]/I");
  
  fTree->Branch("no_primaries",&no_primaries,"no_primaries/I");
  fTree->Branch("geant_list_size",&geant_list_size,"geant_list_size/I");
  
  fTree->Branch("pdg",pdg,"pdg[geant_list_size]/I");
  fTree->Branch("Eng",Eng,"Eng[geant_list_size]/D");
  fTree->Branch("Px",Px,"Px[geant_list_size]/D");
  fTree->Branch("Py",Py,"Py[geant_list_size]/D");
  fTree->Branch("Pz",Pz,"Pz[geant_list_size]/D");
  fTree->Branch("StartPointx",StartPointx,"StartPointx[geant_list_size]/D");
  fTree->Branch("StartPointy",StartPointy,"StartPointy[geant_list_size]/D");
  fTree->Branch("StartPointz",StartPointz,"StartPointz[geant_list_size]/D");
  fTree->Branch("EndPointx",EndPointx,"EndPointx[geant_list_size]/D");
  fTree->Branch("EndPointy",EndPointy,"EndPointy[geant_list_size]/D");
  fTree->Branch("EndPointz",EndPointz,"EndPointz[geant_list_size]/D");
  fTree->Branch("NumberDaughters",NumberDaughters,"NumberDaughters[geant_list_size]/I");
  fTree->Branch("Mother",Mother,"Mother[geant_list_size]/I");
  fTree->Branch("TrackId",TrackId,"TrackId[geant_list_size]/I");
  fTree->Branch("process_primary",process_primary,"process_primary[geant_list_size]/I");
  
  fTree->Branch("no_mcshowers", &no_mcshowers, "no_mcshowers/I");
  fTree->Branch("mcshwr_origin", mcshwr_origin, "mcshwr_origin[no_mcshowers]/D");
  fTree->Branch("mcshwr_pdg", mcshwr_pdg, "mcshwr_pdg[no_mcshowers]/D");
  fTree->Branch("mcshwr_TrackId", mcshwr_TrackId, "mcshwr_TrackId[no_mcshowers]/I");
  fTree->Branch("mcshwr_startX", mcshwr_startX, "mcshwr_startX[no_mcshowers]/D");
  fTree->Branch("mcshwr_startY", mcshwr_startY, "mcshwr_startY[no_mcshowers]/D");
  fTree->Branch("mcshwr_startZ", mcshwr_startZ, "mcshwr_startZ[no_mcshowers]/D");
  fTree->Branch("mcshwr_endX", mcshwr_endX, "mcshwr_endX[no_mcshowers]/D");
  fTree->Branch("mcshwr_endY", mcshwr_endY, "mcshwr_endY[no_mcshowers]/D");
  fTree->Branch("mcshwr_endZ", mcshwr_endZ, "mcshwr_endZ[no_mcshowers]/D");
  fTree->Branch("mcshwr_CombEngX", mcshwr_CombEngX, "mcshwr_CombEngX[no_mcshowers]/D");
  fTree->Branch("mcshwr_CombEngY", mcshwr_CombEngY, "mcshwr_CombEngY[no_mcshowers]/D");
  fTree->Branch("mcshwr_CombEngZ", mcshwr_CombEngZ, "mcshwr_CombEngZ[no_mcshowers]/D");
  fTree->Branch("mcshwr_CombEngPx", mcshwr_CombEngPx, "mcshwr_CombEngPx[no_mcshowers]/D");
  fTree->Branch("mcshwr_CombEngPy", mcshwr_CombEngPy, "mcshwr_CombEngPy[no_mcshowers]/D");
  fTree->Branch("mcshwr_CombEngPz", mcshwr_CombEngPz, "mcshwr_CombEngPz[no_mcshowers]/D");
  fTree->Branch("mcshwr_CombEngE", mcshwr_CombEngE, "mcshwr_CombEngE[no_mcshowers]/D");
  fTree->Branch("mcshwr_dEdx", mcshwr_dEdx, "mcshwr_dEdx[no_mcshowers]/D");
  fTree->Branch("mcshwr_StartDirX", mcshwr_StartDirX, "mcshwr_StartDirX[no_mcshowers]/D");
  fTree->Branch("mcshwr_StartDirY", mcshwr_StartDirY, "mcshwr_StartDirY[no_mcshowers]/D");
  fTree->Branch("mcshwr_StartDirZ", mcshwr_StartDirZ, "mcshwr_StartDirZ[no_mcshowers]/D");
  fTree->Branch("mcshwr_isEngDeposited", mcshwr_isEngDeposited, "mcshwr_isEngDeposited[no_mcshowers]/I");
  fTree->Branch("mcshwr_Motherpdg", mcshwr_Motherpdg, "mcshwr_Motherpdg[no_mcshowers]/I");
  fTree->Branch("mcshwr_MotherTrkId", mcshwr_MotherTrkId, "mcshwr_MotherTrkId[no_mcshowers]/I");
  fTree->Branch("mcshwr_MotherstartX", mcshwr_MotherstartX, "mcshwr_MotherstartX[no_mcshowers]/I");
  fTree->Branch("mcshwr_MotherstartY", mcshwr_MotherstartY, "mcshwr_MotherstartY[no_mcshowers]/I");
  fTree->Branch("mcshwr_MotherstartZ", mcshwr_MotherstartZ, "mcshwr_MotherstartZ[no_mcshowers]/I");
  fTree->Branch("mcshwr_MotherendX", mcshwr_MotherendX, "mcshwr_MotherendX[no_mcshowers]/I");
  fTree->Branch("mcshwr_MotherendY", mcshwr_MotherendY, "mcshwr_MotherendY[no_mcshowers]/I");
  fTree->Branch("mcshwr_MotherendZ", mcshwr_MotherendZ, "mcshwr_MotherendZ[no_mcshowers]/I");
  
  fTree->Branch("mcshwr_Ancestorpdg", mcshwr_Ancestorpdg, "mcshwr_Ancestorpdg[no_mcshowers]/I");
  fTree->Branch("mcshwr_AncestorTrkId", mcshwr_AncestorTrkId, "mcshwr_AncestorTrkId[no_mcshowers]/I");
  fTree->Branch("mcshwr_AncestorstartX", mcshwr_AncestorstartX, "mcshwr_AncestorstartX[no_mcshowers]/I");
  fTree->Branch("mcshwr_AncestorstartY", mcshwr_AncestorstartY, "mcshwr_AncestorstartY[no_mcshowers]/I");
  fTree->Branch("mcshwr_AncestorstartZ", mcshwr_AncestorstartZ, "mcshwr_AncestorstartZ[no_mcshowers]/I");
  fTree->Branch("mcshwr_AncestorendX", mcshwr_AncestorendX, "mcshwr_AncestorendX[no_mcshowers]/I");
  fTree->Branch("mcshwr_AncestorendY", mcshwr_AncestorendY, "mcshwr_AncestorendY[no_mcshowers]/I");
  fTree->Branch("mcshwr_AncestorendZ", mcshwr_AncestorendZ, "mcshwr_AncestorendZ[no_mcshowers]/I");

  
  
}


void LarAnalyzerEg::endJob()
{
  // Implementation of optional member function here.
}



void LarAnalyzerEg::reconfigure(fhicl::ParameterSet const & p)
{
  
  fG4ModuleLabel               = p.get< std::string >("G4ModuleLabel");
  fMCShowerModuleLabel		= p.get< std::string >("MCShowerModuleLabel");
  
  return;
}


void LarAnalyzerEg::ResetVars()
{

  run = -99999;
  subrun = -99999;
  event = -99999;
  evttime = -99999;
  for (int i = 0; i<3; ++i){
    efield[i] = -99999;
  }
  t0 = -99999;
  for (int i = 0; i < 16; ++i){
     trigtime[i]=-99999;
  }
  
  no_primaries = -99999;
  geant_list_size=-999;
  for (int i = 0; i<kMaxPrimaries; ++i){
    pdg[i] = -99999;
    Eng[i] = -99999;
    Px[i] = -99999;
    Py[i] = -99999;
    Pz[i] = -99999;
    StartPointx[i] = -99999;
    StartPointy[i] = -99999;
    StartPointz[i] = -99999;
    EndPointx[i] = -99999;
    EndPointy[i] = -99999;
    EndPointz[i] = -99999;
    NumberDaughters[i] = -99999;
    Mother[i] = -99999;
    TrackId[i] = -99999;
    process_primary[i] = -99999;}


}


DEFINE_ART_MODULE(LarAnalyzerEg)
